<head>
    <title>Инструкция по языку Shar</title>
    <meta charset="utf-8">
</head>

<body>
    <h1>Инструкция по языку Shar</h1>
    <h2>О документе</h2>
    <ul>
        <li>документ является инструкцией по языку программирования Shar</li>
        <li>документ рассчитан на людей которые уже имеют навыки программирования</li>
        <li>документ рассказывает только о самых основах языка Shar</li>
    </ul>
    <h1>Содержание</h1>
    <ul>
        <li><a href="#синтаксис">Синтаксис исходного кода</a></li>
        <li><a href="#функции">Функции</a>
            <ul>
                <li><a href="#аттрибуты_функций">Атрибуты функций</a></li>
                <li><a href="#имена_функций">Имена функций</a></li>
                <li><a href="#аргументы_функций">Аргументы функций</a></li>
                <li><a href="#результаты_функций">Результаты функций</a></li>
            </ul>
        </li>
        <li><a href="#группы_типов">Группы типов</a>
            <ul>
                <li><a href="#имена_групп">Имена групп</a></li>
                <li><a href="#суб_группы">Суб-группы</a></li>
                <li><a href="#функции_групп">Функции групп</a></li>
                <li><a href="#тип_в_группу">Добавление типа в группу</a></li>
            </ul>
        </li>
        <li><a href="#типы">Типы</a>
            <ul>
                <li><a href="#стд_типы">Типы из модуля STD</a></li>
                <li><a href="#пользоватьльские_типы">Пользовательские типы</a></li>
            </ul>
        </li>
        <li><a href="#перечисления">Перечисления</a></li>
        <li><a href="#глобальные_константы">Глобальные константы</a></li>
        <li><a href="#код_функций">Код функций</a>
            <ul>
                <li><a href="#выражения">Выражения</a></li>
                <li><a href="#const_var">Переменные и константы</a></li>
                <li><a href="#for">for</a></li>
                <li><a href="#do">do</a></li>
                <li><a href="#parse">parse</a></li>
                <li><a href="#gparse">gParse</a></li>
                <li><a href="#if">if</a></li>
                <li><a href="#return">return</a></li>
                <li><a href="#switch">switch</a></li>
                <li><a href="#eSwitch">eSwitch</a></li>
                <li><a href="#tSwitch">tSwitch</a></li>
                <li><a href="#test">test</a></li>
                <li><a href="#try">try</a></li>
                <li><a href="#end">end</a></li>
                <li><a href="#next">next</a></li>
                <li><a href="#fallthrough">fallthrough</a></li>
                <li><a href="#nothrow">nothrow</a></li>
                <li><a href="#inthrow">inthrow</a></li>
            </ul>
        </li>
        <li><a href="#вызов_функций">Способы вызова функций</a></li>
        <li><a href="#символьные_операторы">Символьные операторы</a></li>
        <li><a href="#встроенные_функции">Встроенные функции</a></li>
        <li><a href="#обработка_ошибок">Обработка ошибок</a></li>
        <li><a href="#стд_группы">Некоторые группы из стандартного модуля</a></li>
        <li><a href="#многопоточность">Многопоточность</a></li>
        <li><a href="#другое">Другое</a></li>
    </ul>
    <div id="синтаксис">
        <h1>Синтаксис исходного кода</h1>
        Комментарии:
        <ul>
            <li>от <b>//</b> и до конца строки</li>
            <li>от <b>/*</b> и до <b>*/</b>, <b>/*</b> и <b>*/</b> - должны быть в одной строке</li>
        </ul>
        Любой файл с исходным кодом начинается со слова <b>module</b>, а затем, через один или более пробелов, имя модуля.<br>
        Имя модуля должно соответствовать следующим критериям:
        <ul>
            <li>начинается с прописной английской буквы</li>
            <li>все остальные символы имени должны быть либо английской буквой, либо числом, либо знаком подчёркивания</li>
        </ul>
        При компиляции все файлы с исходным кодом, должны указывать одно и то же имя модуля.<br>
        Если имя модуля "Main", то считается, что происходит компиляция конечного приложения, иначе - модуля.<br><br>
        Для формирования исходного кода используются отступы, наподобие того как это делается в таких языках как Python, Haskell.
        Для отступов используются пробелы в количестве кратном 4-м, табуляции не допускаются.
        Если строка заканчивается символом '{', то все последующие строки, до строки с произвольным количеством пробелов и одним символом '}', считаются продолжением текущей строки.
    </div>
    <div id="функции">
        <h1>Функции</h1>
        Для описания функции используется следующий шаблон:
        <pre>
#<i>атрибуты_функции</i>
<b>export def</b> <i>имя_функции</i>(<i>аргументы_функции</i>) <i>тип_результата</i>
    <i>код_функции</i></pre>
        <h2>Экспорт функций</h2>
        Если перед словом <b>def</b> указывается ключевое слово <b>export</b>, то функция будет доступна из других модулей (экспортирована).<br>
        Нельзя одновременно указывать <b>export</b> и атрибут функции <b>override</b>.
        <div id="аттрибуты_функций">
            <h2>Атрибуты функций</h2>
            <ul>
                <li>
                    <h3>alwaysinline</h3>
                    При вызове функции, она не вызывается, а код функции вставляется в место вызова.
                </li>
                <li>
                    <h3>inline</h3>
                    При вызове функции, рекомендуется не вызвать её, а код функции вставить в место вызова.
                </li>
                <li>
                    <h3>noinline</h3>
                    Никогда не вставлять код функции в место вызова.
                </li>
                <li>
                    <h3>cold</h3>
                    При корректной работе программы, считается, что вероятность вызова функции крайне мала.
                </li>
                <li>
                    <h3>nothrow</h3>
                    Если в функцию передаются аргументы с корректными типами, то функция не может выкинуть исключение (подробности в разделе <a href="#обработка_ошибок">обработка ошибок</a>).<br>
                    Если в функции имеющей атрибут nothrow происходит исключение, то результат такого исключения не определён.<br>
                    Атрибут nothrow не может использоваться с атрибутом this (о нём далее), а так же с функциями у которых хотя бы один аргументы имеет групповой тип, за исключением типа $Any. (подробности в разделе <a href="#аргументы_функций">аргументы функций</a>)<br>
                    Данный атрибут является небезопасным и при неправильном использовании может приводить к неопределённому поведению программы.<br>
                    Данный атрибут используется в целях оптимизации, функции с данным атрибутом могут работать значительно эффективнее.
                </li>
                <li>
                    <h3>this(<i>имя_группы</i>)</h3>
                    Функция может использовать тип This, в качестве которого может использоваться любой тип из указанной группы.<br>
                    Хотя бы один из аргументов должен иметь тип This.
                </li>
                <li>
                    <h3>override(<i>имя_модуля</i>)</h3>
                    Данный атрибут переопределяет функцию, объявленную с помощью атрибута this, для конкретного типа.<br>
                    Имя функции и тип определяются из сигнатуры, а модуль в котором находится функция указывается после атрибута override.<br>
                    При переопределении тип любого аргумента функции, а также тип результата функции могут быть изменены на тип являющийся частным случаем типа из функции с аргументом this.<br>
                    Атрибуты this и override не могут использоваться совместно.
                </li>
                <li>
                    <h3>unsafewrite</h3>
                    Функция разрешает использовать групповые типы с изменяемыми аргументами. (подробности в разделе <a href="#аргументы_функций">аргументы функций</a>)<br>
                    Данный атрибут является небезопасным и при неправильном использовании может приводить к неопределённом поведению программы.
                </li>
                <li>
                    <h3>worker</h3>
                    Функция будет запущена в новом потоке, подробности в разделе <a href="#многопоточность">многопоточность</a><br>
                </li>
            </ul>
            В одной функции может использоваться только один из атрибутов alwaysinline, inline, noinline, cold, worker.
        </div>
        <div id="имена_функций">
            <h2>Имена функций</h2>
            Имя функции должно соответствовать следующим критериям:
            <ul>
                <li>начинается со строчной английской буквы</li>
                <li>все остальные символы имени должны быть либо английской буквой, либо числом, либо знаком подчёркивания</li>
                <li>если общее количество символов больше 1, последним символом может быть один из следующих символов <code>'?', '!', '$', '~', '`'</code>.</li>
                <li>имя не должно быть одним из следующих: <code>select, inGroups?, if, for, do, parse, gParse, switch, tSwitch, eSwitch, var, return</code></li>
            </ul>
            Символы <code>'?', '!', '$', '~', '`'</code> в конце имени имеют следующее значение:
            <ul>
                <li>? - функция выясняет верно ли некоторое утверждение</li>
                <li>! - функция убеждается в верности некоторого утверждения и если оно не верно, выполняет некоторое действие</li>
                <li>$ - у функции есть два варианта, один из которых изменяет один из своих аргументов, а второй не изменяет, а возвращает новый вариант аргумента в качестве результата.
                    Второй вариант и заканчивается символом '$'. Пример: sort(a) - отсортирует <i>a</i>, а функция sort$(a) не изменит  <i>a</i>, а вернёт в качестве результата отсортированную копию <i>a</i>
                </li>
                <li>~ - функция возвращает свойство объекта (подробности в разделе <a href="#пользоватьльские_типы">пользовательские типы</a>)</li>
                <li>` - функция устанавливает новое значение свойства и возвращает старое (подробности в разделе <a href="#пользоватьльские_типы">пользовательские типы</a>)</li>
            </ul>
            В одном модуле не может быть 2-х функций с одинаковым именем.
        </div>
        <div id="аргументы_функций">
            <h2>Аргументы функций</h2>
            Для объявления аргументов функции, имена аргументов перечисляются через запятую, а затем через 1 или более пробела тип указанных аргументов, после запятой можно добавить другие аргументы.<br>
            Перед именем аргумента можно указывать два модификатора: <b>write</b> и <b><i>noread</i> </b>.
            Если модификатор не указан - аргумент доступен только для чтения, <i>write</i> - аргумент доступен для чтения и записи, <i>noread</i> - аргумент не доступен для чтения или записи (но можно узнать тип аргумента).<br>
            Пример:
            <pre>
<b>def</b> f(a1, <b>write</b> a2, a3 Int, a4, <b><i>noread</i> </b> a5 $Any)</pre>
            a1, a3, a4 - только чтение<br>
            a2         - запись и чтения<br>
            a5         - не доступен для чтения или записи<br><br>
            a1, a2, a3 - имеют тип Int<br>
            a3, a4, a5 - могут быть любого типа (об этом будет далее)<br><br>
            Если аргумент доступен для записи, то при вызове функции в качестве данного аргумента можно передавать только изменяемый объект.<br>
            Если аргумент доступен только для чтения, то при вызове функции в качестве данного аргумента можно передавать как изменяемый, так и объект доступный только для чтения.<br>
            Если аргумент не доступен для чтения или записи, то при вызове функции в качестве данного аргумента можно передавать любой объект.<br><br>
            При вызове функции нельзя передавать один и тот же объект несколько раз, если хотя бы один раз объект передаётся как изменяемый и хотя бы один раз не как <b><i>noread</i> </b> аргумент.
            <h3>Имена аргументов</h3>
            Имя аргумента должно соответствовать следующим критериям:
            <ul>
                <li>начинается со строчной английской буквы</li>
                <li>все остальные символы имени должны быть либо английской буквой, либо числом, либо знаком подчёркивания</li>
                <li>имя не должно быть одним из следующих: <code>var, const, enum, for, do, parse, gParse, if, elif, select, true, false, switch, tSwitch, eSwitch, case, default, fallthrough, nothing</code></li>
            </ul>
            В одной функции не может быть двух аргументов с одним именем.
            <h3>Типы</h3>
            При указании типа аргумента функции, можно указывать как конкретные типы (наподобие типов из других языков Int, String, Char и т.д., а так же пользовательские типы, подробности в разделе <a href="#пользоватьльские_типы">пользовательские типы</a>) так и групповые типы (о них далее).
            Перед именем типа можно указывать имя модуля из которого этот тип (это может понадобиться если в разных модулях есть тип с одним и тем же именем).<br>
            Шаблон: <code><i>имя_модуля::имя_типа</i></code>
            <h3>Групповые типы</h3>
            В качестве типа аргумента можно указывать, не конкретный тип, а одну или более группу (подробности в разделе <a href="#группы_типов">группы типов</a>).
            При указании группового типа, в качестве аргумента можно передавать в функцию объекты любого типа который является членом всех указанных групп.<br>
            Шаблоны:<br>
            $<i>имя_группы</i><br>
            ${<i>имя_группы_1, имя_группы_2, ... имя_группы_n</i>}<br>
            Перед именем группы можно указывать имя модуля в котором объявлена группа, наподобие того как это делается в конкретных типах.<br>
            Если аргумент имеет групповой тип, то он не может быть изменяемым.
            <h3>Опциональные типы</h3>
            Опциональные типы - это типы, объекты которых могут иметь либо некоторый тип, либо тип STD::Nothing (подробности в разделе <a href="#стд_типы">типы из модуля STD</a>)<br>
            Чтобы указать, что аргумент имеет опциональный тип, нужно перед типом аргумента написать <b>&lt;&gt;</b>.<br>
            Типы STD::Nothing и $STD::Any не могут быть опциональными.<br>
            Если аргумент имеет опциональный тип и является изменяемым, то передаваемый объект должен иметь либо опциональный тип, либо тип $Any.<br>
            Пример:<br>
            <b>def</b> f(a1 &lt;&gt;Int, a2 &lt;&gt;$SomeGroup)
        </div>
        <div id="результаты_функций">
            <h2>Результаты функций</h2>
            После объявления аргументов функции, можно указать тип результата функции.<br>
            Тип результат, подчиняется тем же правилам, что и тип аргументов функций.<br>
            Если тип не указан, то считается, что возвращается объект типа STD::Nothing (подробности в разделе <a href="#стд_типы">типы из модуля STD</a>).
        </div>
    </div>
    <div id="группы_типов">
        <h1>Группы типов</h1>
        Группа типов - это абстракция являющаяся совокупностью типов реализующих некоторое поведение.<br>
        Шаблон:
        <pre>
<b>export group</b> <i>имя_группы</i>: <i>суб_группа_1</i>, <i>суб_группа_2</i>, <i>... суб_группа_n</i>
    <i>имя_функции_1</i>(<i>типы_аргументов</i>) <i>тип_результата</i>
    <i>имя_функции_2</i>(<i>типы_аргументов</i>) <i>тип_результата</i>
    ...
    <i>имя_функции_n</i>(<i>типы_аргументов</i>) <i>тип_результата</i></pre>
        <h2>Экспорт групп</h2>
        Если перед словом <b>group</b> указывается ключевое слово <b>export</b>, то группа будет доступна из других модулей (экспортирована).<br>
        <div id="имена_групп">
            <h2>Имена групп</h2>
            Имя группы должно соответствовать следующим критериям:
            <ul>
                <li>начинается с прописной английской буквы</li>
                <li>все остальные символы имени должны быть либо английской буквой, либо числом, либо знаком подчёркивания</li>
            </ul>
            В одном модуле не может быть 2-х групп с одинаковым именем.
        </div>
        <div id="суб_группы">
            <h2>Суб-группы</h2>
            Если тип являющийся членом группы, то он обязан быть и членом всех его суб-групп.
            Для указания суб-групп, при объявлении группы, после имени ставиться двоеточие и через запятую указываются суб-группы.
        </div>
        <div id="функции_групп">
            <h2>Функции</h2>
            При объявлении группы, можно указывать функции, которые должны реализовывать типы, являющиеся членном данной группы.<br>
            Требования имени функции такие же как и у любой другой функции.<br>
            Типы аргументов объявляются как и аргументы в обычных функциях, но без имён аргументов.<br>
            Функция может использовать тип This и хотя бы один из аргументов должен иметь такой тип. (как у функций с атрибутом <b>this</b>)<br>
            Функции экспортируются только если экспортируется группа.<br>
            Пример:
            <pre>
<b>group</b> Group: SubGroup1, Module::SubGroup2
    f1(Int, This, <b><i>noread</i> </b> String, <b>write</b> String) &lt;&gt;Int
    f2(<b>write</b> This) &lt;&gt;This</pre>
        </div>
        <div id="тип_в_группу">
            <h2>Добавление типа в группу</h2>
            Шаблон:
            <pre>
            <b>attach</b> <i>имя_типа</i> <b>to</b> <i>имя_группы</i>
                <i>определения_функций</i></pre>
            При определении функции можно указывать атрибуты функций, кроме <b>this</b> и <b>override</b>.<br>
            При определении функции, для неё подходят все правила определения функций с атрибутом <b>override</b>.<br>
            Один тип нельзя дважды добавить в одну группу.<br>
            Пример:
            <pre>
<b>group</b> Group
    f(<i>noread</i> This, Int, Int) This

<b>attach</b> Type <b>to</b> Group
    <i>#alwaysinline</i>
    <b>def</b> f(<i>noread</i> type Type, a, b Int) Type
        <b>return</b> Type.fromList({a, b})</pre>
        </div>
    </div>
    <div id="типы">
        <h1>Типы</h1>
        <div id="стд_типы">
            <h2>Типы из модуля STD</h2>
            <ul>
                <li><b>Bool</b> - тип имеющий два значения: <b>true</b> и <b>false</b>.</li>
                <li><b>Int</b> - целые числа из диапазона [-2^63, 2^63). Если в результате какого то действия число выходит за пределы допустимых значений, происходит арифметическое переполнение.</li>
                <li><b>Real</b> - вещественные числа с плавающей точкой двойной точности. Сравнение любого числа с <i>NaN</i> кидает исключение с кодом <b>enum::STD::error_compareWithNaN</b> (подробности в разделах <a href="#перечисления">перечисления</a> и <a href="#обработка_ошибок">обработка ошибок</a>)</li>
                <li><b>Char</b> - юникод символ с кодом из диапазона [0, 65536). Символ заключается между 2-х символов <i>'</i>. Поддерживаются следующие обратные последовательности:
                    <ul>
                        <li><b>\n</b> - символ новой строки</li>
                        <li><b>\t</b> - символ табуляции</li>
                        <li><b>\\</b> - символ <b>\</b></li>
                        <li><b>\q</b> - символ <b>"</b></li>
                        <li><b>\p</b> - символ <b>'</b></li>
                        <li><b>\xxxx</b> - символ с кодом <b>xxxx</b> в шестнадцатеричной системе счисления</li>
                    </ul>
                </li>
                <li><b>String</b> - строки с символами типа <b>STD::Char</b>. Строка заключается между 2-х символов <i>"</i>. Поддерживаются обратные последовательности как в <b>Char</b></li>
                <li>
                    <b>Nothing</b> - тип имеющий одно значение: <b>nothing</b>. <b>nothing</b> - указывает на отсутствие какого либо значения, а не на наличие пустого значения.<br>
                    Тип STD::Nothing является членом группы $Any, но не может быть членом любой другой группы.
                </li>
                <li><b>Array</b> - массив элементы которого имеют одинаковый тип. Тип элементов в пустом массиве - <b>Nothing</b>, в не пустом массиве тип элементов не может быть Nothing. Примеры массивов в коде:<br>
                    [] - пустой массив<br>
                    [1, 2] - массив из 2-х чисел<br>
                    [[1], [3.0], ['c', 'h'], [], ["FFF"]] - массив из массивов<br>
                </li>
                <li><b>List</b> - массив (не смотря на название) элементы которого могут иметь разный тип. Примеры массивов в коде:<br>
                    {} - пустой массив<br>
                    {1, 2} - массив из 2-х чисел<br>
                    {1, 3.0, ['c', 'h'], {}, "FFF"} - массив из элементов различного типа<br>
                </li>
                <li><b>Bytes</b> - массив из байт</li>
                <li><b>Map</b> - ассоциативный массив в котором все ключи имеют один и тот же тип, а так же все значения имеют одинаковый тип</li>
                <li><b>Dict</b> - ассоциативный массив в котором все ключи имеют один и тот же тип, а значения могут иметь различные тип</li>
                <li><b>Set</b> - множество в котором все элементы имеют один и тот же тип</li>
                <li><b>File</b> - тип для работы с файлами.</li>
                <li><b>Time</b> - тип для работы с временем. Способ хранения - количество секунд прошедших с 1 января 00:00 1970 года</li>
                <li><b>Pipeline</b>, <b>PipelineOut</b>, <b>PipelineIn</b> - типы для передачи данных между потоками. (подробности в разделе <a href="#многопоточность">многопоточность</a>)</li>
            </ul>
        </div>
        <div id="пользоватьльские_типы">
            <h2>Пользовательские типы</h2>
            В Shar пользовательские типы по строению идентичны типу <b>STD::List</b>. Способ хранения данных может быть произвольным и определяется программистом, а для работы с данными используются функции.<br>
            Шаблон объявления пользовательских типов:
            <pre><b>export type</b> имя_типа</pre>
            <h3>Экспорт типов</h3>
            Если перед словом <b>type</b> указывается ключевое слово <b>export</b>, то тип будет доступен из других модулей (экспортирован).<br>
            <h3>Имя типа</h3>
            Имя типа должно соответствовать следующим критериям:
            <ul>
                <li>начинается с прописной английской буквы</li>
                <li>все остальные символы имени должны быть либо английской буквой, либо числом, либо знаком подчёркивания</li>
                <li>имя не может быть <b>This</b></li>
            </ul>
            В одном модуле не может быть 2-х типов с одинаковым именем.
            <h3>Функции для работы с пользовательскими типами</h3>
            <code>fromList(<i>noread</i> type <b>This</b>, list <b>List</b>) <b>This</b></code><br>
            Функция возвращает аргумента типа <b>STD::List</b> но уже с пользовательским типом.<br>
            toList(type $<b>Type</b>) <b>List</b><br>
            Функция обратная функции fromList.<br>
            typeGetItem(type $<b>Type</b>, index <b>Int</b>) $<b>Any</b><br>
            Функция получает элемент массива по индексу.<br>
            typeSetItem(<i>write</i> type $<b>Type</b>, index <b>Int</b>, newItem $<b>Any</b>)<br>
            Функция записывает аргумент в массив по индексу.<br>
            typePut(<i>write</i> type $<b>Type</b>, index <b>Int</b>, newItem $<b>Any</b>) $<b>Any</b><br>
            Функция записывает аргумент в массив по индексу и возвращает элемент массива по индексу до записи.<br>
        </div>
    </div>
    <div id="перечисления">
        <h1>Перечисления</h1>
        Шаблон объявления элементов перечисления:
        <pre>
<b>export enum</b>
    <i>элемент_1</i>
    <i>элемент_2</i>
    ...
    <i>элемент_n</i></pre>
        В Shar элемент перечислений является объектом типа STD::Int, который является случайным числом. Два любых элемента не могут быть одинаковым числом.
        Если перед словом <b>enum</b> указывается ключевое слово <b>export</b>, то все элементы будут доступны из других модулей (экспортированные).<br>
        Имя элемента должно соответствовать следующим критериям:
        <ul>
            <li>начинается со строчной английской буквы</li>
            <li>все остальные символы имени должны быть либо английской буквой, либо числом, либо знаком подчёркивания</li>
        </ul>
        В одном модуле не может быть двух элементов с одним именем.<br>
        Для обращения к элементам из кода, используется следующий синтаксис: <code>enum::<i>имя_элемента</i></code>, а так же
        перед именем элемента можно указывать имя модуля в котором элемент объявлен, наподобие того как это делается с типами аргументов функции.
    </div>
    <div id="глобальные_константы">
        <h1>Глобальные константы</h1>
        Глобальные константы - иммутабельные объекты, значение которых доступных в любом выражении.<br>
        Значения констант вычисляются во время запуска приложения.<br>
        Вычисляются значения только тех константы, которые имеют хотя бы теоретическую возможность использования в программе.<br>
        Шаблон объявления глобальных констант:
        <pre><b>export const</b> имя_константы тип_константы = выражение</pre>
        Если перед словом <b>const</b> указывается ключевое слово <b>export</b>, то константа будет доступна из других модулей (экспортирована).<br>
        Имя константы должно соответствовать следующим критериям:
        <ul>
            <li>начинается со строчной английской буквы</li>
            <li>все остальные символы имени должны быть либо английской буквой, либо числом, либо знаком подчёркивания</li>
        </ul>
        В одном модуле не может быть двух глобальных констант с одним именем.<br>
        Для обращения к глобальной константе из кода, используется следующий синтаксис: <code>const::<i>имя_константы</i></code>, а так же
        перед именем глобальной константы можно указывать имя модуля в котором константа объявлена, наподобие того как это делается с типами аргументов функции.
    </div>
    <div id="код_функций">
        <h1>Код функций</h1>
        Поскольку данный документ рассчитан на людей имеющих навыки программирования, то информация о многих операторах которые есть во многих языках программирования, будет даваться
        кратко, но об особенностях этих операндов в Shar, информация даётся подробно.<br>
        Далее следует список того, что может исполняться в функциях.
        <div id="выражения">
            <h2>Выражения</h2>
            Выражение - это программный код который возвращает значение.<br>
            Возможные выражения:
            <ul>
                <li>true, false - тип STD::Bool</li>
                <li>-9223372036854775808..9223372036854775807, 0x0..0xffffffffffffffff - тип STD::Int<br>В шестнадцатеричном виде не допускаются отрицательные числа.</li>
                <li>вещественные числа в виде десятичной дроби или в экспоненциальном виде - тип STD::Real<br>Сравнение любого числа с <i>NaN</i> кидает исключение с кодом <b>enum::STD::error_compareWithNaN</b>.</li>
                <li>символ заключенный между 2-х символов <i>'</i> - тип STD::Char</li>
                <li>строка заключенная между 2-х символов <i>"</i> - тип STD::String</li>
                <li>массивы типа STD::Array и STD::List</li>
                <li>глобальные константы</li>
                <li>элементы перечислений</li>
                <li>объекты не доступные даже для чтения (создаются просто написав имя типа в выражении)</li>
                <li>nothing - тип STD::Nothing</li>
                <li>переменные и константы (о них далее), а так же аргументы функции</li>
                <li>вызов функции (подробности в разделе <a href="#вызов_функций">способы вызова функций</a>)</li>
            </ul>
        </div>
        <div id="const_var">
            <h2>Переменные и константы</h2>
            Переменные и константы - присвоение результату выражения имени.<br>
            Шаблоны:
            <pre><b>const</b> имя_константы тип_константы = выражение</pre>
            <pre><b>var</b> имя_переменной тип_переменной = выражение</pre>
            Правила для имени и типа, такие же как и для аргументов функций.<br>
            Отличие переменной от константы в том, что значение переменной можно менять, а константы нет.<br>
            Для явного изменения значения переменной, используется следующий синтаксис:
            <pre>имя_переменной = выражение</pre>
            Переменная или константа существуют только пока количество отступов в коде не меньше чем при объявлении переменной или константы.<br>
            Одновременно может существовать только одна переменная или константа или аргумент функции с одним именем.<br>
        </div>
        <div id="for">
            <h2>for</h2>
            Шаблоны:
            <pre>
<b>for</b> :(имя_цикла) условие; выражение
    код</pre>
            <pre>
<b>for</b> :(имя_цикла_и_переменной тип_переменной = выражение) условие; выражение
    код</pre>
            Имя цикла должно соответствовать следующим критериям:
            <ul>
                <li>начинается со строчной английской буквы</li>
                <li>все остальные символы имени должны быть либо английской буквой, либо числом, либо знаком подчёркивания</li>
            </ul>
            В одном модуле не может быть двух операторов (for, switch, parse ...) с одним именем.<br>
            Если имя цикла одновременно является и именем переменной, то для имени накладываются и правила для имён переменных.<br>
            Переменная существует только пока работает цикл.<br>
            Имя цикла, условие и выражение не являются обязательными, но если есть выражение, то должно быть и условие.<br>
            Примеры:
            <pre>
<b>for</b> :(loop)
    end loop

<b>for</b> :(i Int = 0) i &lt; 10; i++
    i.println()

<b>for</b>
    10.println()

<b>for</b> true
    10.println()</pre>
        </div>
        <div id="do">
            <h2>do</h2>
            Оператор <b>do</b> служит для уменьшения времени жизни переменных.
            Шаблон:
            <pre>
<b>do</b> :(имя_оператора)
    код</pre>
            Имя оператора должно соответствовать следующим критериям:
            <ul>
                <li>начинается со строчной английской буквы</li>
                <li>все остальные символы имени должны быть либо английской буквой, либо числом, либо знаком подчёркивания</li>
            </ul>
            В одном модуле не может быть двух операторов (do, for, switch, parse ...) с одним именем.<br>
            Имя оператора не является обязательным и если оно отсутствует, то указывать символы <i>:()</i> не нужно.<br>
            Если имя оператора указано, то код из <b>do</b> можно прервать с помощью <b>end </b> имя_оператора.<br>
            Поведение оператора <b>do</b> без указания имени оператора, эквивалентно следующему коду:
            <pre>
<b>if</b> true
    код</pre>
        </div>
        <div id="parse">
            <h2>parse</h2>
            Оператор используется для поэлементного разбора объекта (например массива).<br>
            Шаблон:
            <pre>
<b>parse</b> :(имя_цикла) имя_ключа, имя_элемента = объект
    код</pre>
            Данный оператор является схожим со следующим кодом:
            <pre>
<b>for</b> :(скрытая_переменная $Any = STD::parse__init(объект)) STD::parse__predicate(объект, скрытая_переменная); STD::parse__next(объект, скрытая_переменная)
    <b>const</b> имя_ключа $Any = parse__get__key(объект, скрытая_переменная)
    <b>const</b> имя_элемента $Any = parse__get__item(объект, скрытая_переменная)
    код</pre>
            Имя цикла не обязательно.
            Вместо имени ключа или имени элемента можно указать символ '_', который означает, что ключ или элемент не нужен.
            Примеры:
            <pre>
<b>parse</b> index, item = [1, 2, 3]
    index.println()
    item.println()

<b>parse</b> _, item = []
    item.println()

<b>parse</b> :(parse) _, _ = [1, 2]
    <b>end</b> parse</pre>
        </div>
        <div id="gparse">
            <h2>gParse</h2>
            Оператор используется для поочерёдного получения <b>noread</b> операндов являющихся членами группы.<br>
            Шаблон:
            <pre>
<b>gParse</b> имя_операнда = имя_группы
    код</pre>
            Имя операнда также использовать в операторах <b>end</b> и <b>next</b>.
        </div>
        <div id="if">
            <h2>if</h2>
            Шаблоны:
            <pre>
<b>if</b> условие
    код

<b>if</b> условие
    код_1
<b>else</b>
    код_2

<b>if</b> условие_1
    код_1
<b>elif</b> условие_2
    код_2
...
<b>elif</b> условие_n
    код_n

<b>if</b> условие_1
    код_1
<b>elif</b> условие_2
    код_2
...
<b>elif</b> условие_n
    код_n
<b>else</b>
    код_n+1</pre>
            Все условия должны иметь тип STD::Bool.
            Примеры:
            <pre>
<b>if</b> 10 > 11
    "true".println()

<b>if</b> 10 > 12
    "true".println()
<b>else</b>
    "false".println()

<b>if</b> 10 > 12
    10.println()
<b>elif</b> 134 == 123
    10.println()</pre>
        </div>
        <div id="return">
            <h2>return</h2>
            Шаблон:
            <pre><b>return</b> выражение</pre>
            Оператор завершает работу функции, возвращая результат выражения.
            Если тип результата функции STD::Nothing, то выражение не обязательно.<br>
            Если тип результата функции не STD::Nothing и при этом выполнение функции дошло до конца и не был использован оператор <b>return</b>, то функция кидает исключение с кодом enum::STD::error_noReturnValue.
        </div>
        <div id="switch">
            <h2>switch</h2>
            Шаблон:
            <pre>
<b>switch</b> :(имя_оператора) выражение
<b>case</b> значение_1
    код_1
<b>case</b> значение_2
    код_2
...
<b>case</b> значение_n
    код_n
<b>default</b>
    код_n+1</pre>
            <b>default</b> не является обязательным.<br>
            Имя оператора не является обязательным.<br>
            Тип выражения может иметь одним из следующих: STD::Int, STD::String, STD::Char.<br>
            За один раз может быть указанно несколько значений (через запятую).<br>
            Пример:<br>
            <pre>
<b>switch</b> "abc"
<b>case</b> "rtr"
    "no".println()
<b>case</b>"123", "333s"
    <b>nothing</b>
<b>case</b> "abc"
    "yes".println()
<b>default</b>
    "abc".println()</pre>
        </div>
        <div id="eSwitch">
            <h2>eSwitch</h2>
            Оператор эквивалентен <b>switch</b>, но тип выражения должен быть STD::Int, а в качестве значений используются элементы перечислений (без enum::).
        </div>
        <div id="tSwitch">
            <h2>tSwitch</h2>
            Оператор эквивалентен <b>switch</b>, но тип выражения может быть любым, а в качестве значений используются имена типов.
        </div>
        <div id="test">
            <h2>test</h2>
            Оператор служит для тестирования кода.
            Шаблон:
            <pre>
<b>test</b>: переменная_1, переменная_2
    выражение_1 или выражение_1: код_ошибки_1
    выражение_2 или выражение_2: код_ошибки_2
    ...
    выражение_n или выражение_n: код_ошибки_n</pre>
            Переменная_1 имеет тип STD::Int и увеличивается на единицу, если выражение равно <b>true</b> или если выражение выкинуло исключение с указанным кодом ошибки.<br>
            Переменная_2 имеет тип STD::List и если выражение не равно <b>true</b> или если выражение не выкинуло исключение с указанным кодом ошибки, то к массиву добавляется два элемента:
            <ul>
                <li>имя файл в котором находится выражение (тип STD::String)</li>
                <li>номер строки в котором находится выражение (тип STD::Int)</li>
            </ul>
            Для указания кода ошибки используется элемент перечисления (<b>enum::</b> указывать не нужно).<br>
            Через запятуют можно указать несколько возможных вариантов кода ошибки.
        </div>
        <div id="try">
            <h2>try</h2>
            Подробности в разделе <a href="#обработка_ошибок">обработка ошибок</a>
        </div>
        <div id="end">
            <h2>end</h2>
            Шаблон:
            <code><b>end</b> имя_оператора</code>
            Оператор завершает работу оператора с указанным именем (for, do, parse, gParse, switch, eSwitch, tSwitch).
        </div>
        <div id="next">
            <h2>next</h2>
            Шаблон:
            <code><b>next</b> имя_оператора</code>
            Оператор завершает текущую итерацию цикла с указанным именем (for, parse, gParse) и начинает новую итерацию (если она есть).
        </div>
        <div id="fallthrough">
            <h2>fallthrough</h2>
            Шаблон:
            <code><b>fallthrough</b> имя_оператора</code>
            Оператор перемещает ход выполнения в следующий вариант (case) оператора (switch, eSwitch, tSwitch) с указанным именем.
        </div>
        <div id="nothrow">
            <h2>nothrow</h2>
            Код из оператора <b>nothrow</b> выполняется так, как будто он находится в функции с атрибутом <b>nothrow</b>.<br>
            Оператор не может использоваться в коде функции с атрибутом <b>nothrow</b>, либо внутри оператора <b>nothrow</b>.<br>
            Шаблон:
            <pre>
<b>nothrow</b>
    код</pre>
        </div>
        <div id="inthrow">
            <h2>inthrow</h2>
            Код из оператора <b>inthrow</b> выполняется только если оператор используется в коде, который имеет возможность использовать механизм исключений (не <b>nothrow</b>).<br>
            Шаблон:
            <pre>
<b>inthrow</b>
    код</pre>
        </div>
    </div>
    <div id="вызов_функций">
        <h1>Способы вызова функций</h1>
        В Shar есть несколько способов вызова функции:
        <ul>
            <li>
                Шаблон:
                <code>имя_функции(аргумент_1, аргумент_2, ... аргумент_n)</code>
            </li>
            <li>
                Шаблон:
                <code>аргумент_1.имя_функции(аргумент_2, ... аргумент_n)</code>
            </li>
            <li>
                Шаблон:
                <code>аргумент_1->имя_функции(аргумент_2, ... аргумент_n)</code><br>
                Данный вариант подразумевает, что аргумент_1 имеет тип $Any либо тип является опциональным, если аргумент_1 является <b>nothing</b> то функция возвращает <b>nothing</b>.<br>
                Тип результата вызова, зависит от типа результата функции:
                <table border="1">
                    <tr>
                        <td><b>Тип результата функции</b></td>
                        <td><b>Тип результата вызова</b></td>
                    </tr>
                    <tr>
                        <td>$Any</td>
                        <td>$Any</td>
                    </tr>
                    <tr>
                        <td>STD::Nothing</td>
                        <td>STD::Nothing</td>
                    </tr>
                    <tr>
                        <td>другой_тип</td>
                        <td>&lt;&gt;другой_тип</td>
                    </tr>
                </table>
            </li>
        </ul>
    </div>
    <div id="символьные_операторы">
        <h1>Символьные операторы</h1>
        В выражениях можно вызвать некоторые функции с помощью символьных операторов.<br>
        Символьные операторы имеют приоритет, чем меньше приоритет, тем первее выполнится функция. Если приоритет двух операторов равен, то первым выполнится тот, что в выражении находится левее.<br>
        Вызовы функций в выражении не являющиеся символьными операторами имеют приоритет 0.
        Список символьных операторов:
        <table border="1">
            <tr>
                <td><b>Символьный оператор</b></td>
                <td><b>Приоритет</b></td>
                <td><b>Синтаксис</b></td>
                <td><b>Заменяется на ...</b></td>
            </tr>
            <tr>
                <td>[]</td>
                <td>0</td>
                <td>a[b]</td>
                <td>STD::shar__sugar__getItem(a, b)</td>
            </tr>
            <tr>
                <td>[:]</td>
                <td>0</td>
                <td>a[b : c]</td>
                <td>STD::shar__sugar__getRange(a, b, c)</td>
            </tr>
            <tr>
                <td>++</td>
                <td>1</td>
                <td>a++</td>
                <td>STD::shar__sugar__inc(a)</td>
            </tr>
            <tr>
                <td>--</td>
                <td>1</td>
                <td>a--</td>
                <td>STD::shar__sugar__dec(a)</td>
            </tr>
            <tr>
                <td>!</td>
                <td>2</td>
                <td>!a</td>
                <td>STD::shar__sugar__neg(a)</td>
            </tr>
            <tr>
                <td>*</td>
                <td>3</td>
                <td>a * b</td>
                <td>STD::shar__sugar__mul(a, b)</td>
            </tr>
            <tr>
                <td>/</td>
                <td>3</td>
                <td>a / b</td>
                <td>STD::shar__sugar__div(a, b)</td>
            </tr>
            <tr>
                <td>%</td>
                <td>3</td>
                <td>a % b</td>
                <td>STD::shar__sugar__mod(a, b)</td>
            </tr>
            <tr>
                <td>+</td>
                <td>4</td>
                <td>a + b</td>
                <td>STD::shar__sugar__add(a, b)</td>
            </tr>
            <tr>
                <td>-</td>
                <td>4</td>
                <td>a - b</td>
                <td>STD::shar__sugar__sub(a, b)</td>
            </tr>
            <tr>
                <td>&lt;&lt;</td>
                <td>5</td>
                <td>a &lt;&lt; b</td>
                <td>STD::shar__sugar__shl(a, b)</td>
            </tr>
            <tr>
                <td>&gt;&gt;</td>
                <td>5</td>
                <td>a &gt;&gt; b</td>
                <td>STD::shar__sugar__shr(a, b)</td>
            </tr>
            <tr>
                <td>&lt;</td>
                <td>6</td>
                <td>a &lt; b</td>
                <td>STD::shar__sugar__less(a, b)</td>
            </tr>
            <tr>
                <td>&gt;</td>
                <td>6</td>
                <td>a &gt; b</td>
                <td>STD::shar__sugar__great(a, b)</td>
            </tr>
            <tr>
                <td>&lt;=</td>
                <td>6</td>
                <td>a &lt;= b</td>
                <td>STD::shar__sugar__lessOrEqual(a, b)</td>
            </tr>
            <tr>
                <td>&gt;=</td>
                <td>6</td>
                <td>a &gt;= b</td>
                <td>STD::shar__sugar__greatOrEqual(a, b)</td>
            </tr>
            <tr>
                <td>==</td>
                <td>7</td>
                <td>a == b</td>
                <td>STD::shar__sugar__equal(a, b)</td>
            </tr>
            <tr>
                <td>!=</td>
                <td>7</td>
                <td>a != b</td>
                <td>STD::shar__sugar__notEqual(a, b)</td>
            </tr>
            <tr>
                <td>&amp;</td>
                <td>8</td>
                <td>a &amp; b</td>
                <td>STD::shar__sugar__and(a, b)</td>
            </tr>
            <tr>
                <td>^</td>
                <td>9</td>
                <td>a ^ b</td>
                <td>STD::shar__sugar__xor(a, b)</td>
            </tr>
            <tr>
                <td>|</td>
                <td>10</td>
                <td>a | b</td>
                <td>STD::shar__sugar__or(a, b)</td>
            </tr>
            <tr>
                <td>+=</td>
                <td>11</td>
                <td>a += b</td>
                <td>STD::shar__sugar__addSet(a, b)</td>
            </tr>
            <tr>
                <td>-=</td>
                <td>11</td>
                <td>a -= b</td>
                <td>STD::shar__sugar__subSet(a, b)</td>
            </tr>
            <tr>
                <td>*=</td>
                <td>11</td>
                <td>a *= b</td>
                <td>STD::shar__sugar__mulSet(a, b)</td>
            </tr>
            <tr>
                <td>/=</td>
                <td>11</td>
                <td>a /= b</td>
                <td>STD::shar__sugar__divSet(a, b)</td>
            </tr>
            <tr>
                <td>%=</td>
                <td>11</td>
                <td>a %= b</td>
                <td>STD::shar__sugar__modSet(a, b)</td>
            </tr>
            <tr>
                <td>&amp;=</td>
                <td>11</td>
                <td>a &amp;= b</td>
                <td>STD::shar__sugar__andSet(a, b)</td>
            </tr>
            <tr>
                <td>^=</td>
                <td>11</td>
                <td>a ^= b</td>
                <td>STD::shar__sugar__xorSet(a, b)</td>
            </tr>
            <tr>
                <td>|=</td>
                <td>11</td>
                <td>a |= b</td>
                <td>STD::shar__sugar__orSet(a, b)</td>
            </tr>
            <tr>
                <td>&lt;&lt;=</td>
                <td>11</td>
                <td>a &lt;&lt;= b</td>
                <td>STD::shar__sugar__shlSet(a, b)</td>
            </tr>
            <tr>
                <td>&gt;&gt;=</td>
                <td>11</td>
                <td>a &gt;&gt;= b</td>
                <td>STD::shar__sugar__shrSet(a, b)</td>
            </tr>
        </table>
        Для всех символьных операторов в стандартном модуле есть группа, добавив тип в которую, можно определить поведение символьного оператора.
        Группы имеют такое же имя как и функция на которую заменяются символьные операторы, но первая буква которых - прописная.
    </div>
    <div id="встроенные_функции">
        <h1>Встроенные функции</h1>
        Встроенные функции - функции реализация которых не находится ни в одном модуле, а находится в самом компиляторе.<br>
        <h2>inGroups?</h2>
        Функция <b>inGroups?</b> возвращает <b>true</b> если тип объекта является членом всех перечисленных групп, иначе возвращает <b>false</b>.<br>
        Шаблон:
        <code>inGroups?(аргумент, Группа_1, Группа_2, ... Группа_n)</code>
        <h2>select</h2>
        Функция <b>select</b> первым аргументом принимает объект типа STD::Bool и если первый аргумент равен <b>true</b>, то функция возвращает свой второй аргумент, а если <b>false</b>, то третий.<br>
        Функция высчитывает только тот аргумент, который она возвращает.<br>
        Функция возвращает значение доступное только для чтения.<br>
        Если типы 2-го и 3-го аргумента равны, то тип результата равен этому типу и если тип 2-го или 3-го аргумента опциональный, то тип результата, то же опциональный.<br>
        Если один из аргументов имеет тип не равный $Any или Nothing, а другой Nothing, то результат имеет опциональный тип первого аргумента.<br>
        В остальных случаях, тип результата - $Any.
        <h2>&amp;&amp; ||</h2>
        &amp;&amp; и || - встроенные символьные операторы, которые имеют приоритет 8 и 10 соответственно, имеют 2 аргумента тип которых STD::Bool.<br>
        Шаблон:<br>
        <code>
            a &amp;&amp; b<br>
            a || c<br>
        </code><br>
        &amp;&amp; - логическое и<br>
        || - логическое или<br>
        Операторы вычисляют свой первый аргумент, а второй вычисляется только в том случае, если результата не ясен по первому аргументу.<br>
    </div>
    <div id="обработка_ошибок">
        <h1>Обработка ошибок</h1>
        В Shar для обработки ошибок, используется механизм исключений.<br>
        Для обработки исключений используется операторы <b>try catch</b>.
        Шаблон:
        <pre>
<b>try</b>
    код
<b>catch</b> код_ошибки, сообщение
    код</pre>
        Во время работы программы, выполняется код из <b>try</b>, если этот код кидает исключения, то выполняется код из <b>catch</b>.<br>
        После слова <b>catch</b> могут идти (но не обязательно) два имени константы, в коде из <b>catch</b> эти константы будут означать код ошибки, и сообщение.<br>
        Если одна из констант не нужна, в место имени можно указать символ '_'.<br>
        Тип кода ошибки - STD::Int, тип сообщения - STD::String.<br>
        Сообщение может использоваться только для повторного выбрасывания исключения.<br>
        Компилятор рассчитывает, что корректно работающая программа никогда не кидает исключения.<br>
        Для кидания исключений используется функция throw.<br>
        Шаблон:<br>
        <code>throw(код_ошибки, сообщение)</code><br>
        Если кидается исключение, но его никто не ловит, то программа завершает свою работу и показывает сообщение об ошибке.
    </div>
    <div id="стд_группы">
        <h1>Некоторые группы из стандартного модуля</h1>
        <h2>Any</h2>
        Все типы являются членами группы Any.
        <h2>Container</h2>
        Группа содержит в себе типы, объекты которых содержат в себе различные объекты (STD::Array, STD::List, STD::String).
        <h2>Equal</h2>
        Группа содержит в себе типы, объекты которых можно сравнивать на равенство.
        <h2>Hashable</h2>
        Группа содержит в себе типы, для объектов которых можно высчитывать хэш.
        <h2>Ordered</h2>
        Группа содержит в себе типы, объекты которых можно сравнивать на больше и меньше.
        <h2>StringReader</h2>
        Группа содержит в себе типы, объекты которых можно получать из строк.
        <h2>StringWriter</h2>
        Группа содержит в себе типы, объекты которых можно превращать в строки.
        <h2>Type</h2>
        Группа содержит в себе типы, объявленные с помощью ключевого слова <b>type</b>.
    </div>
    <div id="многопоточность">
        <h1>Многопоточность</h1>
        Многопоточность в Shar реализована следующим образом:<br>
        Есть некоторые специальные функции, выполнение кода которых происходит в новом потоке.<br>
        У таких функции есть вход, из которого приходят объекты от других потоков, и выход, в который функция отправляет объекты другим потокам.<br>
        Если функция прекращает свою работу, то поток закрывается.<br>
        Если во время работы такой функции происходит исключение которое никем не ловится, то поток закрывается, а исключение передаётся на выход функции и выкидывается другим потоком при попытке получить объект из выхода данной функции.<br>
        <br>
        Функции код которых запускается в новом потоке, должны иметь атрибут <b>worker</b> и соответствовать следующему шаблоны:
        <pre>
<b>def</b> <i>имя_функции</i>(<i>вход_функции</i> STD::PipelineOut, <i>вызод_функции</i> STD::PipelineIn)
    <i>код</i></pre>
        Для обмена объектами через поток используются 3 типа:
        <ul>
            <li>Pipeline - тип с помощью которого можно как принимать объекты, так и отправлять их. Используется для организации структуры потоков.</li>
            <li>PipelineOut - тип с помощью которого можно принимать объекты. Является входом функций с атрибутом <b>worker</b></li>
            <li>PipelineIn - тип с помощью которого можно отправлять объекты. Является выходом функций с атрибутом <b>worker</b></li>
        </ul>
        Получать и отправлять можно только объекты, тип которых является членном группы STD::Multithreaded.<br>
        При вычислении глобальных констант запрещено использование потоков.
        Полезные функции из стандартного модуля для работы с многопоточностью:
        <ul>
            <li><b>createPipeline</b>() - создаёт новый объект с типом STD::Pipeline</li>
            <li><b>getPipelineOut</b>(Pipeline) PipelineOut - возвращает объект имеющий тип STD::Pipeline, но уже с типом STD::PipelineOut</li>
            <li><b>getPipelineIn</b>(Pipeline) PipelineIn - возвращает объект имеющий тип STD::Pipeline, но уже с типом STD::PipelineIn</li>
            <li><b>push</b>(Pipeline, $Multithreaded), <b>push</b>(PipelineIn, $Multithreaded) - передаёт объект другим потокам</li>
            <li><b>pop</b>(Pipeline) &lt;&gt;$Multithreaded, <b>pop</b>(PipelineOut) &lt;&gt;$Multithreaded - забирает объект из других потоков, объекты забираются по принципу очереди (первый вошёл, первый вышел).
            Если нечего забирать, то функция возвращает <b>nothing</b>.</li>
            <li><b>yield</b>() - вызов функции указывает на то, что в данный момент потоку нечего делать</li>
            <li><b>sleep</b>(Int) - приостанавливает текущий поток на количество миллисекунд, не меньшее чем передаётся первым аргументом. Функция старается приостановить поток на как можно меньшее время.</li>
        </ul>
        Пример многопоточного кода:<pre>
<b>module</b> Main

<b>def</b> main()
    <b>const</b> mainToWorker Pipeline = createPipeline()
    <b>const</b> workerToMain Pipeline = createPipeline()
    println("Random number: " + <i>const</i>::staticRandomNumber.toString())
    worker(mainToWorker.getPipelineOut(), workerToMain.getPipelineIn())
    worker(mainToWorker.getPipelineOut(), workerToMain.getPipelineIn())
    worker(mainToWorker.getPipelineOut(), workerToMain.getPipelineIn())
    worker(mainToWorker.getPipelineOut(), workerToMain.getPipelineIn())
    mainToWorker.push(<i>const</i>::staticRandomNumber)
    <b>for</b> :(counter Int = 0) counter < 4; counter++
        <b>for</b> :(loop)
            <b>const</b> number <>Int = workerToMain.pop()
            <b>if</b> number.nothing?()
                yield()
            <b>else</b>
                println("Main thread: " + number.toString())
                mainToWorker.push(number * 2)
                <b>end</b> loop

<i>#worker</i>
<b>def</b> worker(in PipelineOut, out PipelineIn)
    <b>for</b> :(loop)
        <b>const</b> number <>Int = in.pop()
        <b>if</b> number.nothing?()
            yield()
        <b>else</b>
            println("Worker thread: " + number.toString())
            out.push(number + 123)
            <b>end</b> loop</pre>
    </div>
    <div id="другое">
        <h1>Другое</h1>
        В Shar используется автоматическое управление ресурсами (не только памятью), момент освобождения ресурса происходит в момент исчезновения всех объектов с ресурсом.<br>
        В Shar объекты считаются независимыми друг от друга, т.е. изменение одного объекта, не влияет на другой. Пример:
        <pre>
var a String = "123"
var b String = a
a.setItem(0, '-')
// a = "-23" b = "123"</pre>
    </div>
</body>
