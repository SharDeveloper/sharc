module Main

// The function replaces the registers created at compile time with llvm ir registers.
#alwaysinline
def sharRegistersToLLVMRegisters(write llvmIR String, firstRegisterNumber Int, errorCoordinates Token)
    var registers Map = Map.createEmpty()
    var registerNumber Int = firstRegisterNumber
    var previousEndEdge Int = 0
    var newLLVMIR String = ""
    const llvmIRLength Int = llvmIR.length~()
    for :(loop)
        const nregIndex <>Int = llvmIR.lookPartFromAtoB("##nreg##", previousEndEdge, llvmIRLength)
        if nregIndex.nothing?()
            end loop
        const endEdge <>Int = llvmIR.lookPartFromAtoB("##", nregIndex + 8, llvmIRLength)
        if endEdge.nothing?()
            errorNotFoundSignatureEnd(errorCoordinates.replaceText("##nreg##"))
        const registerName String = llvmIR[nregIndex + 8 : endEdge]
        if registerName.empty?()
            errorNoRegisterName(errorCoordinates.replaceText("##nreg##"))
        const llvmRegister String = registerNumber.toString()
        registerNumber++
        if !registers.put(registerName, llvmRegister).nothing?()
            errorDoubleDeclaredRegister(errorCoordinates.replaceText(registerName))
        newLLVMIR += llvmIR[previousEndEdge : nregIndex] + llvmRegister
        previousEndEdge = endEdge + 2
    newLLVMIR += llvmIR[previousEndEdge : llvmIRLength]
    llvmIR = newLLVMIR
    newLLVMIR = ""
    previousEndEdge = 0
    const llvmIRNewLength Int = llvmIR.length~()
    for :(loop)
        const regIndex <>Int = llvmIR.lookPartFromAtoB("##reg##", previousEndEdge, llvmIRNewLength)
        if regIndex.nothing?()
            end loop
        const endEdge <>Int = llvmIR.lookPartFromAtoB("##", regIndex + 7, llvmIRNewLength)
        if endEdge.nothing?()
            errorNotFoundSignatureEnd(errorCoordinates.replaceText("##reg##"))
        const registerName String = llvmIR[regIndex + 7 : endEdge]
        if registerName.empty?()
            errorNoRegisterName(errorCoordinates.replaceText("##reg##"))
        const llvmRegister <>String = registers[registerName]
        if llvmRegister.nothing?()
            errorNotFoundRegister(errorCoordinates.replaceText(registerName))
        newLLVMIR += llvmIR[previousEndEdge : regIndex] + llvmRegister
        previousEndEdge = endEdge + 2
    newLLVMIR += llvmIR[previousEndEdge : llvmIRNewLength]
    llvmIR = newLLVMIR

// The function turns a string from source into an array for llvm ir.
#alwaysinline
def stringToLLVMArray(string Token, write llvmStringType String) String
    var chars String = ""
    var charsCount Int = 0
    var hexChar String = ""
    parse _, char = string.text~()
        switch hexChar.length~()
        case 0
            if char == '\\'
                hexChar = "\\"
            else
                charsCount++
                chars += ", i16 " + charToInt(char).toString()
        case 1
            switch char
            case 'n'
                hexChar = ""
                charsCount++
                chars += ", i16 10"
            case 't'
                hexChar = ""
                charsCount++
                chars += ", i16 9"
            case '\\'
                hexChar = ""
                charsCount++
                chars += ", i16 92"
            case 'q'
                hexChar = ""
                charsCount++
                chars += ", i16 34"
            case 'p'
                hexChar = ""
                charsCount++
                chars += ", i16 39"
            default
                hexChar.addItem(char)
        case 4
            var charCode Int = 0
            hexChar.copySelf(1, 0, 3)
            hexChar.setItem(3, char)
            try
                charCode = hexToInt("0x" + hexChar)
            catch
                errorInvalidString(string)
            hexChar = ""
            charsCount++
            chars += ", i16 " + charCode.toString()
        default
            hexChar.addItem(char)
    if !hexChar.empty?()
        errorInvalidString(string)
    llvmStringType = "[" + (charsCount + 8).toString() + " x i16]"
    var result String = "[i16 0, i16 0, i16 0, i16 0"
    for :(counter Int = 0) counter < 4; counter++
        result += ", i16 " + (charsCount & 65535).toString()
        charsCount >>= 16
    result += chars + "]"
    return result

// The function creates llvm code which creates an array.
def createArrayInLLVMIR(write codeData CodeData, itemsTypeNumberRegister String, items Array, write llvmIR String) String
    const arrayLength Int = items.length~()
    const memoryRegister String = codeData.createRegister("call i64* @shar.malloc(i64 " + (arrayLength * 8 + 24).toString() + ")", llvmIR)
    llvmIR += "\tstore i64 1, i64* " + memoryRegister + ", align 8\n"
    const lengthPointerRegister String = codeData.createRegister("getelementptr i64, i64* " + memoryRegister + ", i64 1", llvmIR)
    llvmIR += "\tstore i64 " + arrayLength.toString() + ", i64* " + lengthPointerRegister + ", align 8\n"
    const typePointerRegister String = codeData.createRegister("getelementptr i64, i64* " + memoryRegister + ", i64 2", llvmIR)
    llvmIR += "\tstore i64 " + itemsTypeNumberRegister + ", i64* " + typePointerRegister + ", align 8\n"
    parse index, item = items
        const itemValueRegister String = codeData.createRegister("extractvalue [2 x i64] " + item.value~() + ", 1", llvmIR)
        const itemPointerRegister String = codeData.createRegister("getelementptr i64, i64* " + memoryRegister + ", i64 " + (index + 3).toString(), llvmIR)
        llvmIR += "\tstore i64 " + itemValueRegister + ", i64* " + itemPointerRegister + ", align 8\n"
    const memoryAsI64Register String = codeData.createRegister("ptrtoint i64* " + memoryRegister + " to i64", llvmIR)
    const arrayRegister String = codeData.createRegister("insertvalue [2 x i64] [i64 ##tnum##STD::Array##, i64 0], i64 " + memoryAsI64Register + ", 1", llvmIR)
    return arrayRegister

// The function turns a character from source into a number for llvm ir.
#alwaysinline
def charToLLVMI64(char Token) String
    const cleanedChar String = char.text~()[1 : char.text~().length~() - 1]
    var result String = ""
    if cleanedChar[0] == '\\'
        switch cleanedChar
        case "\\n"
            result = "10"
        case "\\t"
            result = "9"
        case "\\\\"
            result = "92"
        case "\\q"
            result = "34"
        case "\\p"
            result = "39"
        default
            if cleanedChar.length~() != 5
                errorInvalidCharacterInCode(char)
            var resultAsInt Int = 0
            try
                resultAsInt = hexToInt("0x" + cleanedChar[1 : 5])
            catch
                errorInvalidCharacterInCode(char)
            result = resultAsInt.toString()
    elif cleanedChar.length~() == 1
        result = charToInt(cleanedChar[0]).toString()
    else
        errorInvalidCharacterInCode(char)
    return result

// The function turns an integer from source into an integer for llvm ir.
#alwaysinline
def integerToLLVMI64(integer Token) String
    var resultAsInt Int = 0
    const integerText String = integer.text~()
    try
        resultAsInt = (integerText.length~() > 1 && (integerText[1] == 'x' || integerText[1] == 'X')).select(hexToInt(integerText), Int.fromString(integerText))
    catch
        errorInvalidNumber(integer)
    return resultAsInt.toString()

// The function creates llvm code that creates a list.
def createListInLLVMIR(write codeData CodeData, items Array, write llvmIR String) String
    const listLength Int = items.length~()
    const memoryRegister String = codeData.createRegister("call i64* @shar.malloc(i64 " + (listLength * 16 + 16).toString() + ")", llvmIR)
    llvmIR += "\tstore i64 1, i64* " + memoryRegister + ", align 8\n"
    const lengthPointerRegister String = codeData.createRegister("getelementptr i64, i64* " + memoryRegister + ", i64 1", llvmIR)
    llvmIR += "\tstore i64 " + listLength.toString() + ", i64* " + lengthPointerRegister + ", align 8\n"
    parse index, item = items
        const itemTypeRegister String = codeData.createRegister("extractvalue [2 x i64] " + item.value~() + ", 0", llvmIR)
        const itemTypePointerRegister String = codeData.createRegister("getelementptr i64, i64* " + memoryRegister + ", i64 " + (index * 2 + 2).toString(), llvmIR)
        llvmIR += "\tstore i64 " + itemTypeRegister + ", i64* " + itemTypePointerRegister + ", align 8\n"
        const itemValueRegister String = codeData.createRegister("extractvalue [2 x i64] " + item.value~() + ", 1", llvmIR)
        const itemValuePointerRegister String = codeData.createRegister("getelementptr i64, i64* " + memoryRegister + ", i64 " + (index * 2 + 3).toString(), llvmIR)
        llvmIR += "\tstore i64 " + itemValueRegister + ", i64* " + itemValuePointerRegister + ", align 8\n"
    const memoryAsI64Register String = codeData.createRegister("ptrtoint i64* " + memoryRegister + " to i64", llvmIR)
    const listRegister String = codeData.createRegister("insertvalue [2 x i64] [i64 ##tnum##STD::List##, i64 0], i64 " + memoryAsI64Register + ", 1", llvmIR)
    return listRegister

// The function turns a real number from source into a real number for llvm ir.
#alwaysinline
def realToLLVMDouble(real Token) String
    try
        Real.fromString(real.text~())
    catch
        errorInvalidNumber(real)
    return real.text~()

// The function turns a constant string into an operator.
#alwaysinline
def stringToOperand(string Token) Operand
    var value String = ""
    if string.empty?()
        value  = "[i64 ##tnum##STD::String##, i64 ptrtoint ([8 x i16]* @empty.string to i64)]"
    else
        var llvmStringType String = ""
        const llvmStringData String = stringToLLVMArray(string, llvmStringType)
        const llvmString String = "##llvmconst##>private unnamed_addr constant " + llvmStringType + " " + llvmStringData + ", align 8<##"
        value = "[i64 ##tnum##STD::String##, i64 ptrtoint (" + llvmStringType + "* " + llvmString + " to i64)]"
    return Operand(string, enum::access_read, value, OType(string.replaceText("STD::String"), false), true, true, false, false, false)

// The function creates the name of the constant in the llvm ir code.
#alwaysinline
def getConstantLLVMName(constantName String) String
    return "c." + constantName.replacePart$("::", ".")

// The function creates the function name in llvm ir code.
#alwaysinline
def createFunctionLLVMName(fullFunctionName, fullThisTypeName String, checkArgument, mayThrow, isSuperFunction Bool) String
    var suffix String = ""
    switch fullFunctionName[fullFunctionName.length~() - 1]
    case '!'
        suffix = ".1"
    case '?'
        suffix = ".2"
    case '$'
        suffix = ".3"
    case '~'
        suffix = ".4"
    case '`'
        suffix = ".5"
    default
        suffix = ".0"
    var result String = "@f."
    if isSuperFunction
        result += "__super__"
    result += fullFunctionName
    if suffix[1] != '0'
        result.delete(result.length~() - 1, 1)
    if !fullThisTypeName.empty?()
        result += "." + fullThisTypeName
    result.replacePart("::", ".")
    result += suffix + checkArgument.select(".1", ".0") + mayThrow.select(".1", ".0")
    return result

// The function creates llvm ir code by removing any shar inserts from it.
def toFinalLLVMIR(llvmIR String, errorCoordinates Token, compiledData CData, thisType String, write compilingConstants, write compilingFunctions Set, write usedData UsedData, checkArguments, mayThrow Bool) String
    var previousPosition Int = 0
    var result String = ""
    for :(mainLoop)
        const signatureStart <>Int = llvmIR.lookPartFromAtoB("##", previousPosition, llvmIR.length~())
        if signatureStart.nothing?()
            end mainLoop
        result += llvmIR[previousPosition : signatureStart]
        const idPosition Int = signatureStart + 2
        const signatureNext <>Int = llvmIR.lookPartFromAtoB("##", idPosition, llvmIR.length~())
        if signatureNext.nothing?()
            errorNotFoundSignatureMiddle(errorCoordinates)
        const id String = llvmIR[idPosition : signatureNext]
        const signatureEnd <>Int = llvmIR.lookPartFromAtoB("##", signatureNext + 2, llvmIR.length~())
        if signatureEnd.nothing?()
            errorNotFoundSignatureEnd(errorCoordinates.replaceText("##" + id + "##"))
        const context Token = errorCoordinates.replaceText(llvmIR[signatureNext + 2 : signatureEnd])
        previousPosition = signatureEnd + 2
        switch id
        case "tnum"
            var typeName String = ""
            if context.text~() == "This"
                if thisType.empty?()
                    errorNotFound(context, "type")
                typeName = thisType
            else
                typeName = context.text~()
                if !typeName.containPart?("::")
                    errorNotFound(context, "type")
            var typeNumber <>String = usedData.types~()[typeName]
            if typeNumber.nothing?()
                const typeGroups Set = compiledData.getType(context.replaceText(typeName), true).groups~()
                var usedGroupsTypes Map = usedData.groupsTypes`(nothing)
                parse _, group = typeGroups
                    var usedGroupTypes Set = usedGroupsTypes.put(group, Set.createEmpty())
                    usedGroupTypes.add(typeName)
                    usedGroupsTypes.put(group, usedGroupTypes)
                usedData.groupsTypes`(usedGroupsTypes)
                var usedTypes Map = usedData.types`(nothing)
                typeNumber = usedTypes.length~().toString()
                usedTypes.put(typeName, typeNumber)
                usedData.types`(usedTypes)
                parse functionName, groupsNames = usedData.groupsFunctions~()
                    var typeInGroups Bool = true
                    parse :(groupsParse) _, groupName = groupsNames
                        typeInGroups = typeInGroups && typeGroups[groupName]
                    if typeInGroups
                        const functionVariant String = functionName[functionName.length~() - 2 : functionName.length~()]
                        const fullFunctionName String = functionName[0 : functionName.length~() - 2] + "." + typeName + functionVariant
                        compilingFunctions.add(const::emptyToken.replaceText(fullFunctionName))
            result += typeNumber
        case "func", "ancfunc", "ntfunc", "ancntfunc"
            var functionName String = context.text~()
            const isSuperFunction Bool = functionName[0] == '!'
            const separatorIndex <>Int = functionName.lookBack('.')
            var type String = ""
            if !separatorIndex.nothing?()
                type = functionName[separatorIndex + 1 : functionName.length~()]
                functionName = functionName[isSuperFunction.select(1, 0) : separatorIndex]
                if type == "This"
                    type = thisType
            var functionNameSuffix String = ""
            if const::ignoreNoThrow
                functionNameSuffix = "11"
            elif mayThrow
                switch id
                case "ancfunc"
                    functionNameSuffix = "01"
                case "ntfunc"
                    functionNameSuffix = "10"
                case "ancntfunc"
                    functionNameSuffix = "00"
                case "func"
                    functionNameSuffix = "11"
            else
                functionNameSuffix = "00"
            var functionFullName String = isSuperFunction.select("!" + functionName, functionName)
            if !type.empty?()
                functionFullName += "." + type
            functionFullName += functionNameSuffix
            compilingFunctions.add(context.replaceText(functionFullName))
            result += createFunctionLLVMName(functionName, type, functionNameSuffix[0] == '1', functionNameSuffix[1] == '1', isSuperFunction)
        case "ingroups"
            var inGroupsFunctionName <>String = usedData.inGroups~()[context.text~()]
            if inGroupsFunctionName.nothing?()
                var usedInGroups Map = usedData.inGroups`(nothing)
                inGroupsFunctionName = "@in.groups." + usedInGroups.length~().toString()
                usedInGroups.put(context.text~(), inGroupsFunctionName)
                usedData.inGroups`(usedInGroups)
                parse _, groupName = context.text~().split(',')
                    if !groupName.containPart?("::")
                        errorNotFound(context.replaceText(groupName), "group")
                    compiledData.getGroup(context.replaceText(groupName), true)
            result += inGroupsFunctionName
        case "const"
            compilingConstants.add(context)
            result += "@get." + getConstantLLVMName(context.text~())
        case "llvmconst"
            var position Int = signatureNext + 2
            if llvmIR[position] != '>'
                errorNotFoundSignatureEnd(errorCoordinates.replaceText("##" + id + "##"))
            var nesting Int = 1
            for :(loop)
                position++
                if position == llvmIR.length~()
                    errorNotFoundSignatureEnd(errorCoordinates.replaceText("##" + id + "##"))
                if llvmIR.partsEqual?(position, "<##", 0, 3)
                    if nesting == 1
                        end loop
                    nesting--
                    position += 2
                elif llvmIR.partsEqual?(position, "##>", 0, 3)
                    nesting++
                    position += 2
            previousPosition = position + 3
            const constantValue String = toFinalLLVMIR(llvmIR[signatureNext + 3 : position], errorCoordinates, compiledData, thisType, compilingConstants, compilingFunctions, usedData, true, true)
            var constantName <>String = usedData.llvmConstants~()[constantValue]
            if constantName.nothing?()
                var usedLLVMConstants Map = usedData.llvmConstants`(nothing)
                constantName = "@lc." + usedLLVMConstants.length~().toString()
                usedLLVMConstants.put(constantValue, constantName)
                usedData.llvmConstants`(usedLLVMConstants)
            result += constantName
        case "llvmdeclare"
            const declarationEnd <>Int = llvmIR.lookPartFromAtoB("##", signatureEnd + 2, llvmIR.length~())
            if declarationEnd.nothing?()
                errorNotFoundSignatureEnd(errorCoordinates.replaceText("##" + id + "##"))
            const declaration String = llvmIR[signatureEnd + 2 : declarationEnd]
            var usedDeclares Map = usedData.llvmDeclares`(nothing)
            usedDeclares.put(context.text~(), declaration)
            usedData.llvmDeclares`(usedDeclares)
            previousPosition = declarationEnd + 2
        case "enum"
            compiledData.getEnumElementFullName(context, true)
            var elementNumber <>String = usedData.enumerationsElements~()[context.text~()]
            if elementNumber.nothing?()
                var usedEnumerationsElements Map = usedData.enumerationsElements`(nothing)
                elementNumber = usedEnumerationsElements.length~().toString()
                usedEnumerationsElements.put(context.text~(), elementNumber)
                usedData.enumerationsElements`(usedEnumerationsElements)
            result += elementNumber
        case "this"
            var llvmStringType String = ""
            const llvmStringData String = stringToLLVMArray(context.replaceText(context.text~().replacePart$("@", thisType)), llvmStringType)
            const constantValue String = "private unnamed_addr constant " + llvmStringType + " " + llvmStringData + ", align 8"
            var constantName <>String = usedData.llvmConstants~()[constantValue]
            if constantName.nothing?()
                var usedConstants Map = usedData.llvmConstants`(nothing)
                constantName = "@lc." + usedConstants.length~().toString()
                usedConstants.put(constantValue, constantName)
                usedData.llvmConstants`(usedConstants)
            result += llvmStringType + "* " + constantName
        case "flag"
            var replacement String = ""
            switch context.text~()
            case "nothrow"
                replacement = (mayThrow || const::ignoreNoThrow).select("0", "1")
            case "arguments!"
                replacement = (checkArguments || const::ignoreNoThrow).select("1", "0")
            default
                errorUnknownIdentifier(context)
            result += replacement
        case "glist"
            const groupName Token = context
            var constantTypeAndName <>String = usedData.groupListConstants~()[groupName.text~()]
            if constantTypeAndName.nothing?()
                if !groupName.text~().containPart?("::")
                    errorNotFound(context, "group")
                compiledData.getGroup(groupName, true)
                var typesNumbers Array = []
                parse typeName, allTypesWithSameName = compiledData.types~()
                    parse typeModuleName, type = allTypesWithSameName
                        const fullTypeName String = typeModuleName + "::" + typeName
                        if type.groups~()[groupName.text~()]
                            var typeNumber <>String = usedData.types~()[fullTypeName]
                            if typeNumber.nothing?()
                                const typeGroups Set = compiledData.getType(context.replaceText(fullTypeName), true).groups~()
                                var usedGroupsTypes Map = usedData.groupsTypes`(nothing)
                                parse _, group = typeGroups
                                    var usedGroupTypes Set = usedGroupsTypes.put(group, Set.createEmpty())
                                    usedGroupTypes.add(fullTypeName)
                                    usedGroupsTypes.put(group, usedGroupTypes)
                                usedData.groupsTypes`(usedGroupsTypes)
                                var usedTypes Map = usedData.types`(nothing)
                                typeNumber = usedTypes.length~().toString()
                                usedTypes.put(fullTypeName, typeNumber)
                                usedData.types`(usedTypes)
                                parse functionName, groupsNames = usedData.groupsFunctions~()
                                    var typeInGroups Bool = true
                                    parse :(groupsParse) _, usedGroupName = groupsNames
                                        typeInGroups = typeInGroups && typeGroups[usedGroupName]
                                    if typeInGroups
                                        const functionVariant String = functionName[functionName.length~() - 2 : functionName.length~()]
                                        const fullFunctionName String = functionName[0 : functionName.length~() - 2] + "." + fullTypeName + functionVariant
                                        compilingFunctions.add(const::emptyToken.replaceText(fullFunctionName))
                            typesNumbers.addItem(Int.fromString(typeNumber))
                constantTypeAndName = "[" + (typesNumbers.length~() + 1).toString() + " x i64]"
                var constantValue String = "private unnamed_addr constant " + constantTypeAndName + " [i64 " + typesNumbers.length~().toString()
                parse _, typeNumber = typesNumbers
                    constantValue += ", i64 " + typeNumber.toString()
                constantValue += "], align 8"
                var usedLLVMConstants Map = usedData.llvmConstants`(nothing)
                const constantName String = "@lc." + usedLLVMConstants.length~().toString()
                usedLLVMConstants.put(constantValue, constantName)
                usedData.llvmConstants`(usedLLVMConstants)
                constantTypeAndName += "* " + constantName
                var groupListConstants Map = usedData.groupListConstants`(nothing)
                groupListConstants.put(groupName.text~(), constantTypeAndName)
                usedData.groupListConstants`(groupListConstants)
            result += constantTypeAndName
        default
            errorUnknownIdentifier(replaceText(errorCoordinates, id))
    result += llvmIR[previousPosition : llvmIR.length~()]
    result.replacePart("\n\t\n", "\n")
    return result
