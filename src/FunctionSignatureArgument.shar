module Main

type FSArgument
    // access Int
    // type   OType

attach FSArgument to FieldAccess
    #alwaysinline
    def access~(argument FSArgument) Int
        return argument.typeGetItem(0)

    #alwaysinline
    def access`(write argument FSArgument, new Int) Int
        return argument.typePut(0, new)

attach FSArgument to FieldType
    #alwaysinline
    def type~(argument FSArgument) OType
        return argument.typeGetItem(1)

    #alwaysinline
    def type`(write argument FSArgument, new <>OType) <>OType
        return argument.typePut(1, new)

#alwaysinline
def FSArgument(access Int, type OType) FSArgument
    return FSArgument.fromList({access, type})

attach FSArgument to BinarySerializable
    #alwaysinline
    def serialize(argument FSArgument, write bytes Bytes)
        const access Int = argument.access~()
        const type OType = argument.type~()
        var newByte Int = 0
        eSwitch access
        case access_read
            newByte = 1
        case access_write
            newByte = 2
        bytes.addItem(newByte)
        type.serialize(bytes)

    #alwaysinline
    def deserialize(noread type FSArgument, bytes Bytes, write position Int) FSArgument
        const startPosition Int = position
        try
            var access Int = bytes[position]
            position++
            switch access
            case 0
                access = enum::access_noread
            case 1
                access = enum::access_read
            case 2
                access = enum::access_write
            default
                throw(enum::error_outOfRange, "Out of range.", nothing)
            const oType OType = OType.deserialize(bytes, position)
            return FSArgument(access, oType)
        catch id, message, data
            position = startPosition
            throw(id, message, data)

// The function finds out if the arguments are compatible.
#alwaysinline
def argumentCompatible?(compatibleArgument, originalArgument FSArgument, compiledData CData) Bool
    if compatibleArgument.access~() != originalArgument.access~() || (compatibleArgument.type~().optional?() != originalArgument.type~().optional?() && !originalArgument.type~().anyType?())
        return false
    var result Bool = true
    if originalArgument.type~().simple?()
        result = originalArgument.type~().typeEq?(compatibleArgument.type~(), false)
    elif compatibleArgument.type~().simple?()
        const typeGroups Set = compiledData.getType(compatibleArgument.type~().type~(), false).groups~()
        const originalTypeGroups Array = originalArgument.type~().type~()
        parse :(originalGroupsParse) _, originalTypeGroup = originalTypeGroups
            result = typeGroups[originalTypeGroup.text~()]
            if !result
                end originalGroupsParse
    else
        const originalTypeGroups Array = originalArgument.type~().type~()
        const compatibleTypeGroups Array = compatibleArgument.type~().type~()
        var currentIndex Int = 0
        parse :(originalGroupsParse) _, originalTypeGroup = originalTypeGroups
            result = false
            for :(compatibleGroupIndex Int = currentIndex) compatibleGroupIndex < compatibleTypeGroups.length~(); compatibleGroupIndex++
                const compatibleTypeGroup Token = compatibleTypeGroups[compatibleGroupIndex]
                if originalTypeGroup == compatibleTypeGroup
                    currentIndex = compatibleGroupIndex + 1
                    result = true
                    end compatibleGroupIndex
            if !result
                end originalGroupsParse
    return result
