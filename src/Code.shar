module Main

// A function compiles code into a function.
def compileCode(code Array, write codeData CodeData, compiledData CData, write ir String) Bool // lastIsTerminator
    var lastIsTerminator Bool = false
    for :(codeIndex Int = 0) codeIndex < code.length(); codeIndex++
        var currentBlock Block = code[codeIndex]
        if lastIsTerminator
            errorUnreachableCode(currentBlock.line~()[0])
        if {
            currentBlock.line~().length() > 1 &&
            (
                (currentBlock.line~()[1].type!(Token).text~() == "::" || currentBlock.line~()[1].type!(Token).text~() == ".") ||
                currentBlock.line~()[1].type!(Token).text~() == "(" &&
                !(currentBlock.line~()[0].type!(Token).text~() == "if" ||
                    currentBlock.line~()[0].type!(Token).text~() == "return" ||
                    currentBlock.line~()[0].type!(Token).text~() == "for" ||
                    currentBlock.line~()[0].type!(Token).text~() == "switch" ||
                    currentBlock.line~()[0].type!(Token).text~() == "eSwitch" ||
                    currentBlock.line~()[0].type!(Token).text~() == "tSwitch"
                )
            )
        }
            compileExpressionFromBlock(currentBlock, codeData, compiledData, ir).freeOperand(codeData, compiledData, ir)
        else
            switch currentBlock.line~()[0].type!(Token).text~()
            case "=>"
                compilePatternMatching(currentBlock, codeData, compiledData, ir)
            case "const"
                compileConstantDefine(currentBlock, codeData, compiledData, ir)
            case "end"
                compileEnd(currentBlock, codeData, compiledData, ir)
                lastIsTerminator = true
            case "fallthrough"
                compileFallthrough(currentBlock, codeData, compiledData, ir)
                lastIsTerminator = true
            case "for"
                compileFor(currentBlock, codeData, compiledData, ir)
            case "do"
                compileDo(currentBlock, codeData, compiledData, ir)
            case "nothrow"
                compileNothrow(currentBlock, codeData, compiledData, ir)
            case "parse"
                compileParse(currentBlock, codeData, compiledData, ir)
            case "gParse"
                compileGroupParse(currentBlock, codeData, compiledData, ir)
            case "if"
                var ifBlocks Array = []
                for :(loop)
                    ifBlocks.addItem(currentBlock)
                    codeIndex++
                    if codeIndex == code.length()
                        end loop
                    currentBlock = code[codeIndex]
                    const firstToken Token = currentBlock.line~()[0]
                    if !(firstToken.text~() == "elif" || firstToken.text~() == "else")
                        end loop
                codeIndex--
                compileIf(ifBlocks, codeData, compiledData, ir)
            case "next"
                compileNext(currentBlock, codeData, compiledData, ir)
                lastIsTerminator = true
            case "return"
                compileReturn(currentBlock, codeData, compiledData, ir)
                lastIsTerminator = true
            case "switch", "eSwitch", "tSwitch"
                var switchBlocks Array = []
                currentBlock.noSubBlocks!()
                var haveDefault Bool = false
                for :(loop)
                    switchBlocks.addItem(currentBlock)
                    codeIndex++
                    if codeIndex == code.length()
                        end loop
                    currentBlock = code[codeIndex]
                    const firstToken Token = currentBlock.line~()[0]
                    switch firstToken.text~()
                    case "case"
                        if haveDefault
                            errorNotExpectedToken(firstToken, "")
                        currentBlock.subBlocks!()
                    case "default"
                        if haveDefault || switchBlocks.length() == 1
                            errorNotExpectedToken(firstToken, "case")
                        currentBlock.subBlocks!()
                        currentBlock.eol!(1)
                        haveDefault = true
                    default
                        codeIndex--
                        end loop
                if switchBlocks.length() == 1
                    errorNoCase(switchBlocks[0].type!(Block).line~()[0])
                switch switchBlocks[0].type!(Block).line~()[0].type!(Token).text~()
                case "switch"
                    compileSwitch(switchBlocks, haveDefault, codeData, compiledData, ir)
                case "tSwitch"
                    compileTypeSwitch(switchBlocks, haveDefault, codeData, compiledData, ir)
                case "eSwitch"
                    if haveDefault
                        errorESwitchHaveDefault(switchBlocks[switchBlocks.length() - 1].type!(Block).line~()[0])
                    compileEnumSwitch(switchBlocks, codeData, compiledData, ir)
            case "test"
                compileTest(currentBlock, codeData, compiledData, ir)
            case "try"
                const tryBlock Block = currentBlock
                codeIndex++
                if codeIndex == code.length()
                    errorNoCatch(tryBlock.line~()[0])
                const catchBlock Block = code[codeIndex]
                compileTryCatch(tryBlock, catchBlock, codeData, compiledData, ir)
            case "var"
                compileVariableDefine(currentBlock, codeData, compiledData, ir)
            case "inthrow"
                compileInThrow(currentBlock, codeData, compiledData, ir)
            default
                if currentBlock.line~().length() > 1 && currentBlock.line~()[1].type!(Token).text~() == "="
                    compileVariableSet(currentBlock, codeData, compiledData, ir)
                else
                    const operand Operand = compileExpressionFromBlock(currentBlock, codeData, compiledData, ir)
                    if operand.named?()
                        errorNotExpectedToken(operand.code~(), "")
                    operand.freeOperand(codeData, compiledData, ir)
    return lastIsTerminator

// The function compiles the expression contained in the block.
def compileExpressionFromBlock(blockWithExpression Block, write codeData CodeData, compiledData CData, write ir String) Operand
    blockWithExpression.noSubBlocks!()
    var tokenIndex Int = 0
    const result Operand = blockWithExpression.getExpression(tokenIndex).compileExpression(const::anyType, codeData, compiledData, [], ir)
    blockWithExpression.eol!(tokenIndex)
    return result

// => x, y, z = {1, 2, 3}
def compilePatternMatching(block Block, write codeData CodeData, compiledData CData, write ir String)
    block.noSubBlocks!()
    var tokenIndex Int = 1
    var names Array = []
    for :(loop)
        const variableName Token = block.next?(tokenIndex, ["_"]).select(block.line~()[tokenIndex - 1], block.getLowercaseName(tokenIndex, "variable"))
        if variableName[0] != '_' && names.contain?(variableName)
            errorAlreadyExist(variableName, "variable")
        names.addItem(variableName)
        if block.next?(tokenIndex, ["="])
            end loop
        block.next!(tokenIndex, [","])
    const allValues Operand = block.getExpression(tokenIndex).compileExpression(const::anyType, codeData, compiledData, [], ir).toReadOnly(codeData, ir)
    block.eol!(tokenIndex)
    var values Array = allValues.named?().select([], [allValues])
    parse index, name Token = names
        if name[0] != '_'
            const indexAsString String = index.toString()
            const value Operand = {
                callFunction(
                    block.line~()[0].type!(Token).replaceText("STD::shar__sugar__patternMatch"),
                    [
                        allValues,
                        Operand{
                            code          : name.replaceText(indexAsString),
                            access        : Access[read],
                            value         : irInt(indexAsString),
                            type          : const::intType,
                            isConstant    : true,
                            isNamed       : false,
                            isArgument    : false,
                            isGlobalConst : false
                        }
                    ],
                    codeData, compiledData, values, false, false, ir
                )
            }
            const variableOperand <>NamedOperand = codeData.namedOperands~()[name.text~()]
            if variableOperand.nothing?() || variableOperand.operand~().access~() != Access[write]
                errorNotFound(name, "variable")
            value.runtimeTypesCompatibleCheck(variableOperand.operand~().type~(), codeData, compiledData, values, ir)
            values.addItem(value)
    if !allValues.named?()
        allValues.freeOperand(codeData, compiledData, ir)
    var valueIndex Int = allValues.named?().select(0, 1)
    parse _, name Token = names
        if name[0] != '_'
            const operand Operand = codeData.namedOperands~()[name.text~()].type!(NamedOperand).operand~()
            const value Operand = values[valueIndex]
            valueIndex++
            operand.freeOperand(codeData, compiledData, ir)
            irStore(const::objectIRType, value.value~(), operand.value~(), "8", ir)

// The function creates a new constant in the function.
def compileConstantDefine(block Block, write codeData CodeData, compiledData CData, write ir String)
    block.noSubBlocks!()
    var tokenIndex Int = 1
    if block.next?(tokenIndex, ["{"])
        var names Array = []
        var types Array = []
        for :(loop)
            const name Token = block.next?(tokenIndex, ["_"]).select(block.line~()[tokenIndex - 1], block.getLowercaseName(tokenIndex, "constant"))
            switch name.text~()
            case "var", "const", "for", "do", "parse", "gParse", "if", "elif", "select", "super", "true", "false", "switch", "tSwitch", "eSwitch", "case", "default", "fallthrough", "nothing"
                errorInvalidName(name, "constant")
            if name[0] != '_' && names.contain?(name)
                errorAlreadyExist(name, "constant")
            names.addItem(name)
            if !block.next?(tokenIndex, [","])
                const type COType = block.getOperandType(tokenIndex, !codeData.allThisGroups~().empty?()).compileOType(compiledData)
                types += type.repeat(names.length() - types.length(), Array)
                if block.next?(tokenIndex, ["}"])
                    end loop
                block.next!(tokenIndex, [","])
        block.next!(tokenIndex, ["="])
        const allValues Operand = block.getExpression(tokenIndex).compileExpression(const::anyType, codeData, compiledData, [], ir).toReadOnly(codeData, ir)
        block.eol!(tokenIndex)
        var values Array = allValues.named?().select([], [allValues])
        parse index, name Token = names
            if name[0] != '_'
                const indexAsString String = index.toString()
                const value Operand = {
                    callFunction(
                        block.line~()[0].replaceText("STD::shar__sugar__patternMatch"),
                        [
                            allValues,
                            Operand{
                                code          : name.replaceText(indexAsString),
                                access        : Access[read],
                                value         : irInt(indexAsString),
                                type          : const::intType,
                                isConstant    : true,
                                isNamed       : false,
                                isArgument    : false,
                                isGlobalConst : false
                            }
                        ],
                        codeData, compiledData, values, false, false, ir
                    )
                }
                value.runtimeTypesCompatibleCheck(types[index], codeData, compiledData, values, ir)
                values.addItem(value)
        if !allValues.named?()
            allValues.freeOperand(codeData, compiledData, ir)
        var valueIndex Int = allValues.named?().select(0, 1)
        var namedOperands Map = codeData.namedOperands`(Map())
        parse index, name Token = names
            if name[0] != '_'
                var value Operand = values[valueIndex]
                const type COType = types[index]
                valueIndex++
                value = Operand{{
                    code          : name,
                    access        : Access[read],
                    value         : value.value~(),
                    type          : type,
                    isConstant    : false,
                    isNamed       : true,
                    isArgument    : false,
                    isGlobalConst : false
                }}
                if !namedOperands.put(name.text~(), NamedOperand{{
                    level   : codeData.level~(),
                    operand : value,
                    isUsed  : false
                }}).nothing?()
                    errorAlreadyExist(name, "constant")
        codeData.namedOperands`(namedOperands)
    else
        const name Token = block.getLowercaseName(tokenIndex, "constant")
        switch name.text~()
        case "var", "const", "for", "do", "parse", "gParse", "if", "elif", "select", "super", "true", "false", "switch", "tSwitch", "eSwitch", "case", "default", "fallthrough", "nothing"
            errorInvalidName(name, "constant")
        const type COType = block.getOperandType(tokenIndex, !codeData.allThisGroups~().empty?()).compileOType(compiledData)
        block.next!(tokenIndex, ["="])
        var value Operand = block.getExpression(tokenIndex).compileExpression(type, codeData, compiledData, [], ir).toReadOnly(codeData, ir)
        block.eol!(tokenIndex)
        if value.named?()
            value.useOperand(codeData, compiledData, ir)
        if value.Main::constant?() && value.type~().typeEq?(type, true)
            value.code`(name)
            value.isNamed`(true)
        else
            value = Operand{{
                code          : name,
                access        : Access[read],
                value         : value.value~(),
                type          : type,
                isConstant    : false,
                isNamed       : true,
                isArgument    : false,
                isGlobalConst : false
            }}
        var namedOperands Map = codeData.namedOperands`(Map())
        if !namedOperands.put(name.text~(), NamedOperand{{
            level   : codeData.level~(),
            operand : value,
            isUsed  : false
        }}).nothing?()
            errorAlreadyExist(name, "constant")
        codeData.namedOperands`(namedOperands)

// The function compiles the 'end' statement.
def compileEnd(block Block, write codeData CodeData, compiledData CData, write ir String)
    block.noSubBlocks!()
    var tokenIndex Int = 1
    const name Token = block.next(tokenIndex)
    block.eol!(tokenIndex)
    const label <>Label = codeData.endLabels~()[name.text~()]
    if label.nothing?()
        errorNotFound(name, "operator")
    codeData.freeLevel(label.level~(), compiledData, ir)
    irJmp(label.label~(), ir)

// The function compiles the 'fallthrough' statement.
def compileFallthrough(block Block, write codeData CodeData, compiledData CData, write ir String)
    block.noSubBlocks!()
    var tokenIndex Int = 1
    const name Token = block.next(tokenIndex)
    block.eol!(tokenIndex)
    const label <>Label = codeData.fallthroughLabels~()[name.text~()]
    if label.nothing?()
        errorNotFound(name, "operator")
    codeData.freeLevel(label.level~(), compiledData, ir)
    irJmp(label.label~(), ir)

// The function compiles the 'for' statement.
def compileFor(block Block, write codeData CodeData, compiledData CData, write ir String)
    var tokenIndex Int = 1
    var forName Token = const::emptyToken
    codeData.level`(codeData.level~() + 1)
    var haveVariable Bool = false
    if block.next?(tokenIndex, [":"])
        block.next!(tokenIndex, ["("])
        forName = block.getLowercaseName(tokenIndex, "for")
        haveVariable = !block.next?(tokenIndex, [")"])
        if haveVariable
            const type COType = block.getOperandType(tokenIndex, !codeData.allThisGroups~().empty?()).compileOType(compiledData)
            block.next!(tokenIndex, ["="])
            const value Operand = block.getExpression(tokenIndex).compileExpression(type, codeData, compiledData, [], ir).toReadOnly(codeData, ir)
            block.next!(tokenIndex, [")"])
            if value.named?()
                value.useOperand(codeData, compiledData, ir)
            const variableRegister String = codeData.newVariable()
            irStore(const::objectIRType, value.value~(), variableRegister, "8", ir)
            var namedOperands Map = codeData.namedOperands`(Map())
            if !namedOperands.put(forName.text~(), {
                NamedOperand{
                    level   : codeData.level~(),
                    operand : Operand{
                        code          : forName,
                        access        : Access[write],
                        value         : variableRegister,
                        type          : type,
                        isConstant    : false,
                        isNamed       : true,
                        isArgument    : false,
                        isGlobalConst : false
                    },
                    isUsed  : false
                }
            }).nothing?()
                errorAlreadyExist(forName, "variable")
            codeData.namedOperands`(namedOperands)
            codeData.level`(codeData.level~() + 1)
    const forStartLabel String = codeData.createLabel()
    const codeStartLabel String = codeData.createLabel()
    const nextLabel String = codeData.createLabel()
    const endLabel String = codeData.createLabel()
    if !forName.empty?()
        do
            var endLabels Map = codeData.endLabels`(Map())
            if !endLabels.put(forName.text~(), Label{label : endLabel, level : codeData.level~()}).nothing?()
                errorAlreadyExist(forName, "operator")
            codeData.endLabels`(endLabels)
        var nextLabels Map = codeData.nextLabels`(Map())
        if !nextLabels.put(forName.text~(), Label{label : nextLabel, level : codeData.level~()}).nothing?()
            errorAlreadyExist(forName, "operator")
        codeData.nextLabels`(nextLabels)
    irJmp(forStartLabel, ir)
    irLabel(forStartLabel, ir)
    if block.eol?(tokenIndex)
        irJmp(codeStartLabel, ir)
    else
        const predicate String = irTrunc(const::irDataType, irOperandData(block.getExpression(tokenIndex).compileExpression(const::boolType, codeData, compiledData, [], ir), codeData, ir), const::irBoolType, codeData, ir)
        irIf(predicate, Expectation[unknown], codeStartLabel, endLabel, codeData, ir)
    irLabel(codeStartLabel, ir)
    var lastIsTerminator Bool = false
    if !block.subBlocks~().empty?()
        lastIsTerminator = compileCode(block.subBlocks~(), codeData, compiledData, ir)
    if !forName.empty?()
        do
            var endLabels Map = codeData.endLabels`(Map())
            endLabels.put(forName.text~(), nothing)
            codeData.endLabels`(endLabels)
        var nextLabels Map = codeData.nextLabels`(Map())
        nextLabels.put(forName.text~(), nothing)
        codeData.nextLabels`(nextLabels)
    if !lastIsTerminator
        codeData.freeLevel(codeData.level~(), compiledData, ir)
        irJmp(nextLabel, ir)
    codeData.deleteLevel(codeData.level~())
    irLabel(nextLabel, ir)
    if block.next?(tokenIndex, [";"])
        block.getExpression(tokenIndex).compileExpression(const::anyType, codeData, compiledData, [], ir).freeOperand(codeData, compiledData, ir)
    block.eol!(tokenIndex)
    irJmp(forStartLabel, ir)
    irLabel(endLabel, ir)
    if haveVariable
        codeData.freeLevel(codeData.level~(), compiledData, ir)
        codeData.deleteLevel(codeData.level~())

// The function compiles the 'do' statement.
def compileDo(block Block, write codeData CodeData, compiledData CData, write ir String)
    block.subBlocks!()
    var tokenIndex Int = 1
    var doName Token = const::emptyToken
    if block.next?(tokenIndex, [":"])
        block.next!(tokenIndex, ["("])
        doName = block.getLowercaseName(tokenIndex, "do")
        block.next!(tokenIndex, [")"])
    block.eol!(tokenIndex)
    var endLabel String = ""
    if !doName.empty?()
        endLabel = codeData.createLabel()
        var endLabels Map = codeData.endLabels`(Map())
        if !endLabels.put(doName.text~(), Label{label : endLabel, level : codeData.level~()}).nothing?()
            errorAlreadyExist(doName, "operator")
        codeData.endLabels`(endLabels)
    codeData.level`(codeData.level~() + 1)
    const lastIsTerminator Bool = compileCode(block.subBlocks~(), codeData, compiledData, ir)
    if !lastIsTerminator
        codeData.freeLevel(codeData.level~(), compiledData, ir)
        if !doName.empty?()
            irJmp(endLabel, ir)
    codeData.deleteLevel(codeData.level~())
    if !doName.empty?()
        var endLabels Map = codeData.endLabels`(Map())
        endLabels.put(doName.text~(), nothing)
        codeData.endLabels`(endLabels)
        irLabel(endLabel, ir)

// The function compiles the 'nothrow' statement.
def compileNothrow(block Block, write codeData CodeData, compiledData CData, write ir String)
    if codeData.ownerNoThrow~()
        errorNotExpectedToken(block.line~()[0], "")
    codeData.ownerNoThrow`(true)
    block.subBlocks!()
    block.eol!(1)
    codeData.level`(codeData.level~() + 1)
    const lastIsTerminator Bool = compileCode(block.subBlocks~(), codeData, compiledData, ir)
    if !lastIsTerminator
        codeData.freeLevel(codeData.level~(), compiledData, ir)
    codeData.ownerNoThrow`(false)
    codeData.deleteLevel(codeData.level~())

// The function compiles the 'parse' statement.
def compileParse(block Block, write codeData CodeData, compiledData CData, write ir String)
    block.subBlocks!()
    var tokenIndex Int = 1
    var parseName Token = const::emptyToken
    if block.next?(tokenIndex, [":"])
        block.next!(tokenIndex, ["("])
        parseName = block.getLowercaseName(tokenIndex, "parse")
        block.next!(tokenIndex, [")"])
    const keyName Token = block.next?(tokenIndex, ["_"]).select(const::emptyToken, block.getLowercaseName(tokenIndex, "constant"))
    var declaredKeyType COType = const::anyType
    if keyName.empty?()
        block.next!(tokenIndex, [","])
    elif !block.next?(tokenIndex, [","])
        declaredKeyType = block.getOperandType(tokenIndex, !codeData.allThisGroups~().empty?()).compileOType(compiledData)
        block.next!(tokenIndex, [","])
    const itemName Token = block.next?(tokenIndex, ["_"]).select(const::emptyToken, block.getLowercaseName(tokenIndex, "constant"))
    var declaredItemType COType = const::anyType
    if itemName.empty?()
        block.next!(tokenIndex, ["="])
    elif !block.next?(tokenIndex, ["="])
        declaredItemType = block.getOperandType(tokenIndex, !codeData.allThisGroups~().empty?()).compileOType(compiledData)
        block.next!(tokenIndex, ["="])
    codeData.level`(codeData.level~() + 1)
    var parsedOperand Operand = block.getExpression(tokenIndex).compileExpression(const::iterableType, codeData, compiledData, [], ir).toReadOnly(codeData, ir)
    block.eol!(tokenIndex)
    const parsedHideName String = parsedOperand.code~().getUniqID()
    if parsedOperand.named?()
        parsedOperand.useOperand(codeData, compiledData, ir)
    else
        parsedOperand.isNamed`(true)
        parsedOperand.code`(const::emptyToken.replaceText(parsedHideName))
    do
        var namedOperands Map = codeData.namedOperands`(Map())
        namedOperands.put(parsedHideName, NamedOperand{{
            operand : parsedOperand,
            level   : codeData.level~(),
            isUsed  : true
        }})
        codeData.namedOperands`(namedOperands)
    var hiddenIndex Operand = callFunction(const::emptyToken.replaceText("STD::parse__init"), [parsedOperand], codeData, compiledData, [], false, false, ir)
    const hiddenIndexVariableName String = parsedHideName + ".index"
    do
        const indexVariable String = codeData.newVariable()
        irStore(const::objectIRType, hiddenIndex.value~(), indexVariable, "8", ir)
        hiddenIndex = Operand{{
            code          : const::emptyToken.replaceText(hiddenIndexVariableName),
            access        : Access[write],
            value         : indexVariable,
            type          : hiddenIndex.type~(),
            isConstant    : false,
            isNamed       : true,
            isArgument    : false,
            isGlobalConst : false
        }}
        var namedOperands Map = codeData.namedOperands`(Map())
        namedOperands.put(hiddenIndexVariableName, NamedOperand{{
            operand : hiddenIndex,
            level   : codeData.level~(),
            isUsed  : true
        }})
        codeData.namedOperands`(namedOperands)
    codeData.level`(codeData.level~() + 1)
    const parseStartLabel String = codeData.createLabel()
    const codeStartLabel String = codeData.createLabel()
    const nextLabel String = codeData.createLabel()
    const endLabel String = codeData.createLabel()
    if !parseName.empty?()
        do
            var endLabels Map = codeData.endLabels`(Map())
            if !endLabels.put(parseName.text~(), Label{label : endLabel, level : codeData.level~()}).nothing?()
                errorAlreadyExist(parseName, "operator")
            codeData.endLabels`(endLabels)
        var nextLabels Map = codeData.nextLabels`(Map())
        if !nextLabels.put(parseName.text~(), Label{label : nextLabel, level : codeData.level~()}).nothing?()
            errorAlreadyExist(parseName, "operator")
        codeData.nextLabels`(nextLabels)
    irJmp(parseStartLabel, ir)
    irLabel(parseStartLabel, ir)
    do
        const predicate Operand = callFunction(const::emptyToken.replaceText("STD::parse__predicate"), [parsedOperand, hiddenIndex], codeData, compiledData, [], false, false, ir)
        irIf(irTrunc(const::irDataType, irOperandData(predicate, codeData, ir), const::irBoolType, codeData, ir), Expectation[unknown], codeStartLabel, endLabel, codeData, ir)
        irLabel(codeStartLabel, ir)
    if !keyName.empty?()
        var key Operand = callFunction(const::emptyToken.replaceText("STD::parse__get__key"), [parsedOperand, hiddenIndex], codeData, compiledData, [], false, false, ir)
        key.code`(keyName)
        key.runtimeTypesCompatibleCheck(declaredKeyType, codeData, compiledData, [key], ir)
        if key.type~().anyType?() || (declaredKeyType.simple?() && (!key.type~().simple?() || (!declaredKeyType.optional?() && key.type~().optional?())))
            key.type`(declaredKeyType)
        key.isNamed`(true)
        var namedOperands Map = codeData.namedOperands`(Map())
        if !namedOperands.put(keyName.text~(), NamedOperand{{
            operand : key,
            level   : codeData.level~(),
            isUsed  : false
        }}).nothing?()
            errorAlreadyExist(keyName, "constant")
        codeData.namedOperands`(namedOperands)
    if !itemName.empty?()
        var item Operand = callFunction(const::emptyToken.replaceText("STD::parse__get__item"), [parsedOperand, hiddenIndex], codeData, compiledData, [], false, false, ir)
        item.code`(itemName)
        item.runtimeTypesCompatibleCheck(declaredItemType, codeData, compiledData, [item], ir)
        if item.type~().anyType?() || (declaredItemType.simple?() && (!item.type~().simple?() || (!declaredItemType.optional?() && item.type~().optional?())))
            item.type`(declaredItemType)
        item.isNamed`(true)
        var namedOperands Map = codeData.namedOperands`(Map())
        if !namedOperands.put(itemName.text~(), NamedOperand{{
            operand : item,
            level   : codeData.level~(),
            isUsed  : false
        }}).nothing?()
            errorAlreadyExist(itemName, "constant")
        codeData.namedOperands`(namedOperands)
    const lastIsTerminator Bool = compileCode(block.subBlocks~(), codeData, compiledData, ir)
    if !parseName.empty?()
        do
            var endLabels Map = codeData.endLabels`(Map())
            endLabels.put(parseName.text~(), nothing)
            codeData.endLabels`(endLabels)
        var nextLabels Map = codeData.nextLabels`(Map())
        nextLabels.put(parseName.text~(), nothing)
        codeData.nextLabels`(nextLabels)
    if !lastIsTerminator
        codeData.freeLevel(codeData.level~(), compiledData, ir)
        irJmp(nextLabel, ir)
    codeData.deleteLevel(codeData.level~())
    irLabel(nextLabel, ir)
    callFunction(const::emptyToken.replaceText("STD::parse__next"), [parsedOperand, hiddenIndex], codeData, compiledData, [], false, false, ir)
    irJmp(parseStartLabel, ir)
    irLabel(endLabel, ir)
    codeData.freeLevel(codeData.level~(), compiledData, ir)
    codeData.deleteLevel(codeData.level~())

// The function compiles the 'gParse' statement.
def compileGroupParse(block Block, write codeData CodeData, compiledData CData, write ir String)
    block.subBlocks!()
    var tokenIndex Int = 1
    const typeConstantName Token = block.getLowercaseName(tokenIndex, "constant")
    block.next!(tokenIndex, ["="])
    const groupName Token = block.getFullUppercaseName(tokenIndex, "group")
    const groupFullName String = compiledData.getGroup(groupName, false).fullName~()
    block.eol!(tokenIndex)
    const parseStartLabel String = codeData.createLabel()
    const loopStartLabel String = codeData.createLabel()
    const codeStartLabel String = codeData.createLabel()
    const nextLabel String = codeData.createLabel()
    const endLabel String = codeData.createLabel()
    irJmp(parseStartLabel, ir)
    irLabel(parseStartLabel, ir)
    const countAndTypes String = irGroupTypesList(groupFullName, codeData, ir)
    const count String = irLoad(const::irGroupIndexType, countAndTypes, "4", codeData, ir)
    irJmp(loopStartLabel, ir)
    irLabel(loopStartLabel, ir)
    const incTypeIndex String = codeData.registerCounter~().toString()
    codeData.registerCounter`(codeData.registerCounter~() + 1)
    const typeIndex String = irPhi(const::irGroupIndexType, ["1", irRegNumberToReg(incTypeIndex)], [parseStartLabel, nextLabel], codeData, ir)
    irIf(irUle(const::irGroupIndexType, typeIndex, count, codeData, ir), Expectation[unknown], codeStartLabel, endLabel, codeData, ir)
    irLabel(codeStartLabel, ir)
    codeData.level`(codeData.level~() + 1)
    do
        const noReadValue String = irLoad(const::irTypeOfType, irOffsetPtr(const::irTypeOfType, countAndTypes, irZext(const::irTypeOfType, typeIndex, const::irDataType, codeData, ir), codeData, ir), "4", codeData, ir)
        var namedOperands Map = codeData.namedOperands`(Map())
        if !namedOperands.put(typeConstantName.text~(), NamedOperand{{
            operand : Operand{
                code          : typeConstantName,
                access        : Access[noread],
                value         : noReadValue,
                type          : const::anyType,
                isConstant    : false,
                isNamed       : true,
                isArgument    : false,
                isGlobalConst : false
            },
            level   : codeData.level~(),
            isUsed  : false
        }}).nothing?()
            errorAlreadyExist(typeConstantName, "constant")
        codeData.namedOperands`(namedOperands)
    do
        var endLabels Map = codeData.endLabels`(Map())
        if !endLabels.put(typeConstantName.text~(), Label{label : endLabel, level : codeData.level~()}).nothing?()
            errorAlreadyExist(typeConstantName, "operator")
        codeData.endLabels`(endLabels)
    do
        var nextLabels Map = codeData.nextLabels`(Map())
        if !nextLabels.put(typeConstantName.text~(), Label{label : nextLabel, level : codeData.level~()}).nothing?()
            errorAlreadyExist(typeConstantName, "operator")
        codeData.nextLabels`(nextLabels)
    const lastIsTerminator Bool = compileCode(block.subBlocks~(), codeData, compiledData, ir)
    do
        var endLabels Map = codeData.endLabels`(Map())
        endLabels.put(typeConstantName.text~(), nothing)
        codeData.endLabels`(endLabels)
    do
        var nextLabels Map = codeData.nextLabels`(Map())
        nextLabels.put(typeConstantName.text~(), nothing)
        codeData.nextLabels`(nextLabels)
    if !lastIsTerminator
        codeData.freeLevel(codeData.level~(), compiledData, ir)
        irJmp(nextLabel, ir)
    irLabel(nextLabel, ir)
    irIncIndexRegister(const::irGroupIndexType, incTypeIndex, typeIndex, ir)
    irJmp(loopStartLabel, ir)
    irLabel(endLabel, ir)
    codeData.deleteLevel(codeData.level~())

// The function compiles the 'if' statement.
def compileIf(ifBlocks Array, write codeData CodeData, compiledData CData, write ir String)
    var trueLabel String = ""
    var falseLabel String = ""
    const endLabel String = codeData.createLabel()
    parse blockIndex, block Block = ifBlocks
        block.subBlocks!()
        var tokenIndex Int = 1
        var predicate String = ""
        const firstToken Token = block.line~()[0]
        switch firstToken.text~()
        case "if", "elif"
            if firstToken.text~() == "if" && blockIndex != 0
                errorNotExpectedToken(firstToken, "else")
            block.notEOL!(tokenIndex)
            predicate = irTrunc(const::irDataType, irOperandData(block.getExpression(tokenIndex).compileExpression(const::boolType, codeData, compiledData, [], ir), codeData, ir), const::irBoolType, codeData, ir)
            trueLabel = codeData.createLabel()
            falseLabel = (blockIndex + 1 == ifBlocks.length()).select(endLabel, codeData.createLabel())
        case "else"
            if blockIndex + 1 != ifBlocks.length()
                errorNotExpectedToken(firstToken, "elif")
            block.eol!(1)
            falseLabel = endLabel
        default
            errorNotExpectedToken(firstToken, "else")
        if !predicate.empty?()
            irIf(predicate, Expectation[unknown], trueLabel, falseLabel, codeData, ir)
            irLabel(trueLabel, ir)
        codeData.level`(codeData.level~() + 1)
        const lastIsTerminator Bool = compileCode(block.subBlocks~(), codeData, compiledData, ir)
        if !lastIsTerminator
            codeData.freeLevel(codeData.level~(), compiledData, ir)
            irJmp(endLabel, ir)
        codeData.deleteLevel(codeData.level~())
        irLabel(falseLabel, ir)

// The function compiles the 'return' statement.
def compileReturn(block Block, write codeData CodeData, compiledData CData, write ir String)
    block.noSubBlocks!()
    var tokenIndex Int = 1
    var returnIRValue String = ""
    var enslavedOperand <>NamedOperand = nothing
    if block.eol?(tokenIndex) && codeData.resultType~().nothingType?()
        returnIRValue = const::irNothing
    else
        const returnValue Operand = block.getExpression(tokenIndex).compileExpression(codeData.resultType~(), codeData, compiledData, [], ir).toReadOnly(codeData, ir)
        block.eol!(tokenIndex)
        if returnValue.named?()
            if returnValue.argument?()
                returnValue.useOperand(codeData, compiledData, ir)
            else
                var namedOperands Map = codeData.namedOperands`(Map())
                enslavedOperand = namedOperands.put(returnValue.code~().text~(), nothing)
                codeData.namedOperands`(namedOperands)
        if codeData.functionNameForErrorMessage~().hasPrefix?("const::")
            returnValue.operandToConst(codeData, compiledData, ir)
        returnIRValue = returnValue.value~()
    codeData.freeLevel(1, compiledData, ir)
    irReturn(returnIRValue, ir)
    if !enslavedOperand.nothing?()
        const operandName String = enslavedOperand.operand~().code~().text~()
        do
            var namedOperands Map = codeData.namedOperands`(Map())
            namedOperands.put(operandName, enslavedOperand)
            codeData.namedOperands`(namedOperands)
        codeData.markVariableAsChanged(operandName)

// The function compiles the 'next' statement.
def compileNext(block Block, write codeData CodeData, compiledData CData, write ir String)
    block.noSubBlocks!()
    var tokenIndex Int = 1
    const name Token = block.next(tokenIndex)
    block.eol!(tokenIndex)
    const label <>Label = codeData.nextLabels~()[name.text~()]
    if label.nothing?()
        errorNotFound(name, "operator")
    codeData.freeLevel(label.level~(), compiledData, ir)
    irJmp(label.label~(), ir)

// The function compiles the 'switch' statement.
def compileSwitch(switchBlocks Array, haveDefault Bool, write codeData CodeData, compiledData CData, write ir String)
    const switchBlock Block = switchBlocks[0]
    var tokenIndex Int = 1
    var switchName Token = const::emptyToken
    if switchBlock.next?(tokenIndex, [":"])
        switchBlock.next!(tokenIndex, ["("])
        switchName = switchBlock.getLowercaseName(tokenIndex, "switch")
        switchBlock.next!(tokenIndex, [")"])
    switchBlocks[1].notEOL!(1)
    var expectedType COType = const::anyType
    switch switchBlocks[1].type!(Block).line~()[1][0]
    case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '+'
        expectedType = const::intType
    case '\q'
        expectedType = const::stringType
    case '\p'
        expectedType = const::charType
    default
        errorNotExpectedToken(switchBlocks[1].type!(Block).line~()[1], "")
    const operand Operand = switchBlock.getExpression(tokenIndex).compileExpression(expectedType, codeData, compiledData, [], ir).toReadOnly(codeData, ir)
    switchBlock.eol!(tokenIndex)
    const endLabel String = codeData.createLabel()
    var labels Array = []
    const casesBlocks Array = switchBlocks[1:]
    parse _, _ = casesBlocks
        labels.addItem(codeData.createLabel())
    switch expectedType.type~()[5]
    case 'I'
        createIntSwitch(casesBlocks, operand, haveDefault, labels, endLabel, codeData, ir)
    case 'S'
        createStringSwitch(casesBlocks, operand, haveDefault, labels, endLabel, codeData, ir)
        if !operand.named?()
            codeData.level`(codeData.level~() + 1)
            const stringUniqName String = operand.code~().getUniqID()
            var namedOperands Map = codeData.namedOperands`(Map())
            namedOperands.put(stringUniqName, NamedOperand{{
                operand : operand,
                level   : codeData.level~(),
                isUsed  : true
            }})
            codeData.namedOperands`(namedOperands)
    case 'C'
        createCharSwitch(casesBlocks, operand, haveDefault, labels, endLabel, codeData, ir)
    if !switchName.empty?()
        var endLabels Map = codeData.endLabels`(Map())
        if !endLabels.put(switchName.text~(), Label{label : endLabel, level : codeData.level~() + 1}).nothing?()
            errorAlreadyExist(switchName, "operator")
        codeData.endLabels`(endLabels)
    parse caseIndex, caseBlock Block = casesBlocks
        codeData.level`(codeData.level~() + 1)
        const allowFallthrough Bool = !(switchName.empty?() || caseIndex + 1 == casesBlocks.length())
        if allowFallthrough
            var fallthroughLabels Map = codeData.fallthroughLabels`(Map())
            fallthroughLabels.put(switchName.text~(), Label{label : labels[caseIndex + 1], level : codeData.level~()})
            codeData.fallthroughLabels`(fallthroughLabels)
        irLabel(labels[caseIndex], ir)
        const lastIsTerminator Bool = compileCode(caseBlock.subBlocks~(), codeData, compiledData, ir)
        if !lastIsTerminator
            codeData.freeLevel(codeData.level~(), compiledData, ir)
            irJmp(endLabel, ir)
        codeData.deleteLevel(codeData.level~())
        if allowFallthrough
            var fallthroughLabels Map = codeData.fallthroughLabels`(Map())
            fallthroughLabels.put(switchName.text~(), nothing)
            codeData.fallthroughLabels`(fallthroughLabels)
    irLabel(endLabel, ir)
    if !switchName.empty?()
        var endLabels Map = codeData.endLabels`(Map())
        endLabels.put(switchName.text~(), nothing)
        codeData.endLabels`(endLabels)
    if expectedType.type~()[5] == 'S' && !operand.named?()
        codeData.freeLevel(codeData.level~(), compiledData, ir)
        codeData.deleteLevel(codeData.level~())

// The function creates a llvm ir "switch" statement for the type "STD::Int".
def createIntSwitch(casesBlocks Array, operand Operand, haveDefault Bool, labels Array, endLabel String, write codeData CodeData, write ir String)
    var switchVariantsAndLabels Map = Map()
    const caseIndexEdge Int = casesBlocks.length() + haveDefault.select(-1, 0)
    for :(caseIndex Int = 0) caseIndex < caseIndexEdge; caseIndex++
        const caseBlock Block = casesBlocks[caseIndex]
        var tokenIndex Int = 1
        for :(loop)
            const numberToken Token = caseBlock.next(tokenIndex)
            var variant String = ""
            try
                var number Int = 0
                if numberToken.text~().contain?('x')
                    number = hexToInt(numberToken.text~())
                else
                    number = Int.fromString(numberToken.text~())
                variant = number.toString()
            catch
                errorNotExpectedToken(numberToken, "")
            if !switchVariantsAndLabels.put(variant, labels[caseIndex]).nothing?()
                errorAlreadyExist(numberToken, "case")
            if caseBlock.eol?(tokenIndex)
                end loop
            caseBlock.next!(tokenIndex, [","])
    irSwitch(const::irDataType, irOperandData(operand, codeData, ir), haveDefault.select(labels[labels.length() - 1], endLabel), switchVariantsAndLabels, ir)

// The function creates a llvm ir "switch" statement for the type "STD::String".
def createStringSwitch(casesBlocks Array, operand Operand, haveDefault Bool, labels Array, endLabel String, write codeData CodeData, write ir String)
    var casesStringsAndLabels Map = Map()
    const caseIndexEdge Int = casesBlocks.length() + haveDefault.select(-1, 0)
    for :(caseIndex Int = 0) caseIndex < caseIndexEdge; caseIndex++
        const caseBlock Block = casesBlocks[caseIndex]
        var tokenIndex Int = 1
        for :(loop)
            const stringToken Token = caseBlock.next(tokenIndex)
            if stringToken[0] != '\q'
                errorNotExpectedToken(stringToken, "")
            const rawString String = stringToRaw(stringToken)
            if !casesStringsAndLabels.put(rawString, labels[caseIndex]).nothing?()
                errorAlreadyExist(stringToken, "case")
            if caseBlock.eol?(tokenIndex)
                end loop
            caseBlock.next!(tokenIndex, [","])
    // Map(Int, [label switch of one length, |string, label of case code |...])
    var lengths Array = []
    var casesByLength Map = Map()
    parse rawString, label String = casesStringsAndLabels
        const currentLength Int = rawString.length()
        var allCasesWithSameLength <>Array = casesByLength.put(currentLength, [])
        if allCasesWithSameLength.nothing?()
            lengths.addItem(currentLength)
            allCasesWithSameLength = (currentLength != 0).select([codeData.createLabel(), rawString, label], [label])
        else
            allCasesWithSameLength += [rawString, label]
        casesByLength.put(currentLength, allCasesWithSameLength)
    lengths.sort(true)
    const irStringLength String = irLoad(const::irStringLengthType, irOffsetPtr(const::irStringLengthType, irIntToPtr(irOperandData(operand, codeData, ir), const::irStringLengthType, codeData, ir), "1", codeData, ir), "8", codeData, ir)
    const irCharsPointer String = irOffsetPtr(const::irCharType, irIntToPtr(irOperandData(operand, codeData, ir), const::irCharType, codeData, ir), "4", codeData, ir)
    const defaultOrEndLabel String = haveDefault.select(labels[labels.length() - 1], endLabel)
    var switchVariantsAndLabels Map = Map()
    parse _, length Int = lengths
        const stringsWithSameLength Array = casesByLength[length]
        switchVariantsAndLabels.put(length.toString(), stringsWithSameLength[0])
    irSwitch(const::irStringLengthType, irStringLength, defaultOrEndLabel, switchVariantsAndLabels, ir)
    parse _, length Int = lengths
        if length != 0
            const stringsWithSameLength Array = casesByLength[length]
            createIRSwitchesForStrings(stringsWithSameLength, defaultOrEndLabel, irCharsPointer, codeData, ir)

// The function generates llvm ir code that searches for a string unknown at compile time among the strings known at compile time.
// All strings known at compile time must be of the same length.
#noinline
def createIRSwitchesForStrings(stringsWithSameLength Array, defaultOrEndLabel, irCharsPointer String, write codeData CodeData, write ir String)
    irLabel(stringsWithSameLength[0], ir)
    const irChar String = irLoad(const::irCharType, irCharsPointer, "4", codeData, ir)
    if stringsWithSameLength[1].length() == 1
        var switchVariantsAndLabels Map = Map()
        for :(stringIndex Int = 1) stringIndex < stringsWithSameLength.length(); stringIndex += 2
            switchVariantsAndLabels.put(charToInt(stringsWithSameLength[stringIndex][0]).toString(), stringsWithSameLength[stringIndex + 1])
        irSwitch(const::irCharType, irChar, defaultOrEndLabel, switchVariantsAndLabels, ir)
    else
        var switchVariantsAndLabels Map = Map()
        var stringsTails Map = Map()
        for :(stringIndex Int = 1) stringIndex < stringsWithSameLength.length(); stringIndex += 2
            const string String = stringsWithSameLength[stringIndex]
            const label String = stringsWithSameLength[stringIndex + 1]
            const char Char = string[0]
            const tail String = string[1:]
            var existedTails <>Array = stringsTails.put(char, [])
            if existedTails.nothing?()
                const charLabel String = codeData.createLabel()
                switchVariantsAndLabels.put(charToInt(char).toString(), charLabel)
                existedTails = [charLabel, tail, label]
            else
                existedTails.addItem(tail)
                existedTails.addItem(label)
            stringsTails.put(char, existedTails)
        const nextCharPointer String = irOffsetPtr(const::irCharType, irCharsPointer, "1", codeData, ir)
        irSwitch(const::irCharType, irChar, defaultOrEndLabel, switchVariantsAndLabels, ir)
        parse _, tails Array = stringsTails
            createIRSwitchesForStrings(tails, defaultOrEndLabel, nextCharPointer, codeData, ir)

// The function creates a llvm ir "switch" statement for the type "STD::Char".
def createCharSwitch(casesBlocks Array, operand Operand, haveDefault Bool, labels Array, endLabel String, write codeData CodeData, write ir String)
    var switchVariantsAndLabels Map = Map()
    const caseIndexEdge Int = casesBlocks.length() + haveDefault.select(-1, 0)
    for :(caseIndex Int = 0) caseIndex < caseIndexEdge; caseIndex++
        const caseBlock Block = casesBlocks[caseIndex]
        var tokenIndex Int = 1
        for :(loop)
            const charToken Token = caseBlock.next(tokenIndex)
            if charToken[0] != '\p'
                errorNotExpectedToken(charToken, "")
            const irChar String = charToIRInt(charToken)
            if !switchVariantsAndLabels.put(irChar, labels[caseIndex]).nothing?()
                errorAlreadyExist(charToken, "case")
            if caseBlock.eol?(tokenIndex)
                end loop
            caseBlock.next!(tokenIndex, [","])
    irSwitch(const::irCharType, irTrunc(const::irDataType, irOperandData(operand, codeData, ir), const::irCharType, codeData, ir), haveDefault.select(labels[labels.length() - 1], endLabel), switchVariantsAndLabels, ir)

// The function compiles the 'tSwitch' statement.
def compileTypeSwitch(switchBlocks Array, haveDefault Bool, write codeData CodeData, compiledData CData, write ir String)
    const switchBlock Block = switchBlocks[0]
    var tokenIndex Int = 1
    var switchName Token = const::emptyToken
    if switchBlock.next?(tokenIndex, [":"])
        switchBlock.next!(tokenIndex, ["("])
        switchName = switchBlock.getLowercaseName(tokenIndex, "switch")
        switchBlock.next!(tokenIndex, [")"])
    const operand Operand = switchBlock.getExpression(tokenIndex).compileExpression(const::anyType, codeData, compiledData, [], ir).toReadOnly(codeData, ir)
    switchBlock.eol!(tokenIndex)
    if !operand.named?()
        operand.freeOperand(codeData, compiledData, ir)
    const endLabel String = codeData.createLabel()
    if !switchName.empty?()
        var endLabels Map = codeData.endLabels`(Map())
        if !endLabels.put(switchName.text~(), Label{label : endLabel, level : codeData.level~() + 1}).nothing?()
            errorAlreadyExist(switchName, "operator")
        codeData.endLabels`(endLabels)
    const casesBlocks Array = switchBlocks[1:]
    var labels Array = []
    do
        var switchVariantsAndLabels Map = Map()
        parse caseIndex, caseBlock Block = casesBlocks
            const currentLabel String = codeData.createLabel()
            labels.addItem(currentLabel)
            if !(caseIndex + 1 == casesBlocks.length() && haveDefault)
                tokenIndex = 1
                for :(loop)
                    if caseBlock.next?(tokenIndex, ["<>", "$"])
                        errorNotExpectedToken(caseBlock.line~()[tokenIndex - 1], "")
                    const type OType = caseBlock.getOperandType(tokenIndex, false)
                    const variant String = sharTypeToIRType(type.compileOType(compiledData).type~())
                    if !switchVariantsAndLabels.put(variant, currentLabel).nothing?()
                        errorAlreadyExist(oTypeToToken(type, false), "case")
                    if caseBlock.eol?(tokenIndex)
                        end loop
                    caseBlock.next!(tokenIndex, [","])
        irSwitch(const::irTypeOfType, irOperandTypeNumber(operand, codeData, ir), haveDefault.select(labels[labels.length() - 1], endLabel), switchVariantsAndLabels, ir)
    parse caseIndex, caseBlock Block = casesBlocks
        codeData.level`(codeData.level~() + 1)
        const allowFallthrough Bool = !(switchName.empty?() || caseIndex + 1 == casesBlocks.length())
        if allowFallthrough
            var fallthroughLabels Map = codeData.fallthroughLabels`(Map())
            fallthroughLabels.put(switchName.text~(), Label{label : labels[caseIndex + 1], level : codeData.level~()})
            codeData.fallthroughLabels`(fallthroughLabels)
        irLabel(labels[caseIndex], ir)
        const lastIsTerminator Bool = compileCode(caseBlock.subBlocks~(), codeData, compiledData, ir)
        if !lastIsTerminator
            codeData.freeLevel(codeData.level~(), compiledData, ir)
            irJmp(endLabel, ir)
        codeData.deleteLevel(codeData.level~())
        if allowFallthrough
            var fallthroughLabels Map = codeData.fallthroughLabels`(Map())
            fallthroughLabels.put(switchName.text~(), nothing)
            codeData.fallthroughLabels`(fallthroughLabels)
    irLabel(endLabel, ir)
    if !switchName.empty?()
        var endLabels Map = codeData.endLabels`(Map())
        endLabels.put(switchName.text~(), nothing)
        codeData.endLabels`(endLabels)

// The function compiles the 'eSwitch' statement.
def compileEnumSwitch(switchBlocks Array, write codeData CodeData, compiledData CData, write ir String)
    const switchBlock Block = switchBlocks[0]
    var tokenIndex Int = 1
    var switchName Token = const::emptyToken
    if switchBlock.next?(tokenIndex, [":"])
        switchBlock.next!(tokenIndex, ["("])
        switchName = switchBlock.getLowercaseName(tokenIndex, "switch")
        switchBlock.next!(tokenIndex, [")"])
    const operand Operand = switchBlock.getExpression(tokenIndex).compileExpression(const::anyType, codeData, compiledData, [], ir).toReadOnly(codeData, ir)
    switchBlock.eol!(tokenIndex)
    if !operand.type~().simple?() || operand.type~().optional?()
        errorESwitchTypeNotSimpleOrOptional(operand.code~(), coTypeToString(operand.type~(), true))
    var elements Map = Map()
    do
        const enumeration CType = compiledData.getType(const::emptyToken.replaceText(operand.type~().type~()), false)
        if !enumeration.enum?()
            errorNotEnumType(operand.code~().replaceText(operand.type~().type~()))
        var elementsArray Array = []
        parse element String, _ = enumeration.fields~()
            elementsArray.addItem(element)
        elementsArray.sort(true)
        parse elementID, elementName String = elementsArray
            elements.put(elementName, elementID)
    const endLabel String = codeData.createLabel()
    const unreachableLabel String = codeData.createLabel()
    if !switchName.empty?()
        var endLabels Map = codeData.endLabels`(Map())
        if !endLabels.put(switchName.text~(), Label{label : endLabel, level : codeData.level~() + 1}).nothing?()
            errorAlreadyExist(switchName, "operator")
        codeData.endLabels`(endLabels)
    var switchVariantsAndLabels Map = Map()
    const casesBlocks Array = switchBlocks[1:]
    var labels Array = []
    parse _, caseBlock Block = casesBlocks
        const currentLabel String = codeData.createLabel()
        labels.addItem(currentLabel)
        tokenIndex = 1
        for :(loop)
            const elementName Token = caseBlock.getLowercaseName(tokenIndex, "enumeration element")
            const elementID <>Int = elements[elementName.text~()]
            if elementID.nothing?()
                errorNotFound(elementName, "enumeration element")
            if !switchVariantsAndLabels.put(elementID.toString(), currentLabel).nothing?()
                errorAlreadyExist(elementName, "case")
            if caseBlock.eol?(tokenIndex)
                end loop
            caseBlock.next!(tokenIndex, [","])
    if switchVariantsAndLabels.length() < elements.length()
        errorESwitchNotEnoughtElements(switchBlocks[0].type!(Block).line~()[0])
    irSwitch(const::irEnumElementType, irTrunc(const::irDataType, irOperandData(operand, codeData, ir), const::irEnumElementType, codeData, ir), unreachableLabel, switchVariantsAndLabels, ir)
    parse caseIndex, caseBlock Block = casesBlocks
        codeData.level`(codeData.level~() + 1)
        const allowFallthrough Bool = !switchName.empty?() && caseIndex + 1 != casesBlocks.length()
        if allowFallthrough
            var fallthroughLabels Map = codeData.fallthroughLabels`(Map())
            fallthroughLabels.put(switchName.text~(), Label{label : labels[caseIndex + 1], level : codeData.level~()})
            codeData.fallthroughLabels`(fallthroughLabels)
        irLabel(labels[caseIndex], ir)
        const lastIsTerminator Bool = compileCode(caseBlock.subBlocks~(), codeData, compiledData, ir)
        if !lastIsTerminator
            codeData.freeLevel(codeData.level~(), compiledData, ir)
            irJmp(endLabel, ir)
        codeData.deleteLevel(codeData.level~())
        if allowFallthrough
            var fallthroughLabels Map = codeData.fallthroughLabels`(Map())
            fallthroughLabels.put(switchName.text~(), nothing)
            codeData.fallthroughLabels`(fallthroughLabels)
    irLabel(unreachableLabel, ir)
    irUnreachable(ir)
    irLabel(endLabel, ir)
    if !switchName.empty?()
        var endLabels Map = codeData.endLabels`(Map())
        endLabels.put(switchName.text~(), nothing)
        codeData.endLabels`(endLabels)

// The function compiles the 'test' statement.
def compileTest(testBlock Block, write codeData CodeData, compiledData CData, write ir String)
    testBlock.subBlocks!()
    var tokenIndex Int = 1
    testBlock.next!(tokenIndex, [":"])
    const successCounter Operand = testBlock.getExpression(tokenIndex).compileExpression(const::intType, codeData, compiledData, [], ir)
    if successCounter.access~() != Access[write]
        errorWrongAccess(successCounter.code~(), "write", successCounter.access~().toString())
    testBlock.next!(tokenIndex, [","])
    const errorsCoordinates Operand = testBlock.getExpression(tokenIndex).compileExpression(const::listType, codeData, compiledData, [], ir)
    if errorsCoordinates.access~() != Access[write]
        errorWrongAccess(errorsCoordinates.code~(), "write", errorsCoordinates.access~().toString())
    testBlock.eol!(tokenIndex)
    parse _, testedExpressionBlock Block = testBlock.subBlocks~()
        testedExpressionBlock.noSubBlocks!()
        tokenIndex = 0
        const testedExpression $Expression = testedExpressionBlock.getExpression(tokenIndex)
        var expectedErrorCodes Array = []
        if !testedExpressionBlock.eol?(tokenIndex)
            testedExpressionBlock.next!(tokenIndex, [":"])
            for :(loop)
                expectedErrorCodes.addItem(testedExpressionBlock.next(tokenIndex))
                if !testedExpressionBlock.next?(tokenIndex, [","])
                    end loop
            testedExpressionBlock.eol!(tokenIndex)
        const okLabel String = codeData.createLabel()
        const endOkLabel String = codeData.createLabel()
        const errorLabel String = codeData.createLabel()
        const finalLabel String = codeData.createLabel()
        do
            var catchLabels Array = codeData.catchLabels`([])
            catchLabels.addItem(Label{label : errorLabel, level : codeData.level~() + 1})
            codeData.catchLabels`(catchLabels)
        const expectedType COType = expectedErrorCodes.empty?().select(const::boolType, const::anyType)
        const testedResultOperand Operand = testedExpression.compileExpression(expectedType, codeData, compiledData, [], ir)
        irJmp(okLabel, ir)
        irLabel(okLabel, ir)
        var irTestedResultValue String = ""
        if expectedErrorCodes.empty?()
            irTestedResultValue = irTrunc(const::irDataType, irOperandData(testedResultOperand, codeData, ir), const::irBoolType, codeData, ir)
        else
            testedResultOperand.freeOperand(codeData, compiledData, ir)
            irJmp(endOkLabel, ir)
            irLabel(endOkLabel, ir)
        irJmp(finalLabel, ir)
        irLabel(errorLabel, ir)
        do
            var catchLabels Array = codeData.catchLabels`([])
            catchLabels.delete(catchLabels.length() - 1, 1)
            codeData.catchLabels`(catchLabels)
        const error String = irLoad(const::objectIRType, codeData.getErrorVariableRegister(), "8", codeData, ir)
        var isExpectedError String = ""
        if !expectedErrorCodes.empty?()
            const errorID String = irObjectData(irGetErrorID(error, codeData, ir), codeData, ir)
            parse _, errorCode Token = expectedErrorCodes
                const errorValueConstant CConstant = compiledData.getConstant(errorCode, false)
                if !errorValueConstant.type~().typeEq?(const::intType, true)
                    errorInvalidType(errorCode, coTypeToString(errorValueConstant.type~(), true), "STD::Int")
                const errorValue String = irObjectData(irConst(errorValueConstant.fullName~(), codeData, ir), codeData, ir)
                const isCurrrentError String = irEq(const::irDataType, errorID, errorValue, codeData, ir)
                if isExpectedError.empty?()
                    isExpectedError = isCurrrentError
                else
                    irOr(isExpectedError, isCurrrentError, codeData, ir)
        irFreeError(error, codeData.threadDataRegister~(), ir)
        irJmp(finalLabel, ir)
        irLabel(finalLabel, ir)
        const testResultValue String = expectedErrorCodes.empty?().select({
            irPhi(const::irBoolType, [irTestedResultValue, const::irFalse], [okLabel, errorLabel], codeData, ir),
            irPhi(const::irBoolType, [const::irFalse, isExpectedError], [endOkLabel, errorLabel], codeData, ir)
        })
        const successLabel String = codeData.createLabel()
        const failLabel String = codeData.createLabel()
        const endLabel String = codeData.createLabel()
        irIf(testResultValue, Expectation[true], successLabel, failLabel, codeData, ir)
        irLabel(successLabel, ir)
        callFunction(const::emptyToken.replaceText("STD::shar__sugar__inc"), [successCounter], codeData, compiledData, [], false, false, ir)
        irJmp(endLabel, ir)
        irLabel(failLabel, ir)
        const failCoordinates Token = testedResultOperand.code~()
        do
            const failFileOperand Operand = Operand{{
                code          : failCoordinates,
                access        : Access[read],
                value         : irString(failCoordinates.replaceText("\q" + failCoordinates.fileName~() + "\q")),
                type          : const::stringType,
                isConstant    : true,
                isNamed       : false,
                isArgument    : false,
                isGlobalConst : false
            }}
            callFunction(const::emptyToken.replaceText("STD::addItem"), [errorsCoordinates, failFileOperand], codeData, compiledData, [], false, false, ir)
        do
            const lineToken Token = failCoordinates.replaceText((failCoordinates.lineIndex~() + 1).toString())
            const failLineOperand Operand = Operand{{
                code          : lineToken,
                access        : Access[read],
                value         : irInt(lineToken.text~()),
                type          : const::intType,
                isConstant    : true,
                isNamed       : false,
                isArgument    : false,
                isGlobalConst : false
            }}
            callFunction(const::emptyToken.replaceText("STD::addItem"), [errorsCoordinates, failLineOperand], codeData, compiledData, [], false, false, ir)
        irJmp(endLabel, ir)
        irLabel(endLabel, ir)

// The function compiles the 'try' statement.
def compileTryCatch(tryBlock, catchBlock Block, write codeData CodeData, compiledData CData, write ir String)
    tryBlock.subBlocks!()
    catchBlock.subBlocks!()
    tryBlock.eol!(1)
    const catchLabel String = codeData.createLabel()
    const endLabel String = codeData.createLabel()
    codeData.level`(codeData.level~() + 1)
    do
        var catchLabels Array = codeData.catchLabels`([])
        catchLabels.addItem(Label{label : catchLabel, level : codeData.level~()})
        codeData.catchLabels`(catchLabels)
    var lastIsTerminator Bool = compileCode(tryBlock.subBlocks~(), codeData, compiledData, ir)
    if !lastIsTerminator
        codeData.freeLevel(codeData.level~(), compiledData, ir)
        irJmp(endLabel, ir)
    codeData.deleteLevel(codeData.level~())
    do
        var catchLabels Array = codeData.catchLabels`([])
        catchLabels.delete(catchLabels.length() - 1, 1)
        codeData.catchLabels`(catchLabels)
    irLabel(catchLabel, ir)
    var tokenIndex Int = 0
    catchBlock.next!(tokenIndex, ["catch"])
    const error String = irLoad(const::objectIRType, codeData.getErrorVariableRegister(), "8", codeData, ir)
    var idName Token = const::emptyToken
    var messageName Token = const::emptyToken
    var dataName Token = const::emptyToken
    if !catchBlock.eol?(1)
        if !catchBlock.next?(tokenIndex, ["_"])
            idName = catchBlock.getLowercaseName(tokenIndex, "constant")
        catchBlock.next!(tokenIndex, [","])
        if !catchBlock.next?(tokenIndex, ["_"])
            messageName = catchBlock.getLowercaseName(tokenIndex, "constant")
        catchBlock.next!(tokenIndex, [","])
        if !catchBlock.next?(tokenIndex, ["_"])
            dataName = catchBlock.getLowercaseName(tokenIndex, "constant")
        catchBlock.eol!(tokenIndex)
    codeData.level`(codeData.level~() + 1)
    if !idName.empty?()
        var namedOperands Map = codeData.namedOperands`(Map())
        if !namedOperands.put(idName.text~(), NamedOperand{{
            level   : codeData.level~(),
            operand : Operand{
                code          : idName,
                access        : Access[read],
                value         : irGetErrorID(error, codeData, ir),
                type          : const::intType,
                isConstant    : false,
                isNamed       : true,
                isArgument    : false,
                isGlobalConst : false
            },
            isUsed  : false
        }}).nothing?()
            errorAlreadyExist(idName, "constant")
        codeData.namedOperands`(namedOperands)
    if !messageName.empty?()
        const messageOperand Operand = Operand{{
            code          : messageName,
            access        : Access[read],
            value         : irGetErrorMessage(error, codeData, ir),
            type          : const::stringType,
            isConstant    : false,
            isNamed       : true,
            isArgument    : false,
            isGlobalConst : false
        }}
        messageOperand.useOperand(codeData, compiledData, ir)
        var namedOperands Map = codeData.namedOperands`(Map())
        if !namedOperands.put(messageName.text~(), NamedOperand{{
            level   : codeData.level~(),
            operand : messageOperand,
            isUsed  : false
        }}).nothing?()
            errorAlreadyExist(messageName, "constant")
        codeData.namedOperands`(namedOperands)
    if !dataName.empty?()
        const dataOperand Operand = Operand{{
            code          : dataName,
            access        : Access[read],
            value         : irGetErrorData(error, codeData, ir),
            type          : const::anyType,
            isConstant    : false,
            isNamed       : true,
            isArgument    : false,
            isGlobalConst : false
        }}
        dataOperand.useOperand(codeData, compiledData, ir)
        var namedOperands Map = codeData.namedOperands`(Map())
        if !namedOperands.put(dataName.text~(), NamedOperand{{
            level   : codeData.level~(),
            operand : dataOperand,
            isUsed  : false
        }}).nothing?()
            errorAlreadyExist(dataName, "constant")
        codeData.namedOperands`(namedOperands)
    irFreeError(error, codeData.threadDataRegister~(), ir)
    lastIsTerminator = compileCode(catchBlock.subBlocks~(), codeData, compiledData, ir)
    if !lastIsTerminator
        codeData.freeLevel(codeData.level~(), compiledData, ir)
        irJmp(endLabel, ir)
    codeData.deleteLevel(codeData.level~())
    irLabel(endLabel, ir)

// The function creates a new variable in the function.
def compileVariableDefine(block Block, write codeData CodeData, compiledData CData, write ir String)
    block.noSubBlocks!()
    var tokenIndex Int = 1
    if block.next?(tokenIndex, ["{"])
        var names Array = []
        var types Array = []
        for :(loop)
            const name Token = block.next?(tokenIndex, ["_"]).select(block.line~()[tokenIndex - 1], block.getLowercaseName(tokenIndex, "variable"))
            switch name.text~()
            case "var", "const", "for", "do", "parse", "gParse", "if", "elif", "select", "super", "true", "false", "switch", "tSwitch", "eSwitch", "case", "default", "fallthrough", "nothing"
                errorInvalidName(name, "variable")
            if name[0] != '_' && names.contain?(name)
                errorAlreadyExist(name, "variable")
            names.addItem(name)
            if !block.next?(tokenIndex, [","])
                const type COType = block.getOperandType(tokenIndex, !codeData.allThisGroups~().empty?()).compileOType(compiledData)
                types += type.repeat(names.length() - types.length(), Array)
                if block.next?(tokenIndex, ["}"])
                    end loop
                block.next!(tokenIndex, [","])
        block.next!(tokenIndex, ["="])
        const allValues Operand = block.getExpression(tokenIndex).compileExpression(const::anyType, codeData, compiledData, [], ir).toReadOnly(codeData, ir)
        block.eol!(tokenIndex)
        var values Array = allValues.named?().select([], [allValues])
        parse index, name Token = names
            if name[0] != '_'
                const indexAsString String = index.toString()
                const value Operand = {
                    callFunction(
                        block.line~()[0].replaceText("STD::shar__sugar__patternMatch"),
                        [
                            allValues,
                            Operand{
                                code          : name.replaceText(indexAsString),
                                access        : Access[read],
                                value         : irInt(indexAsString),
                                type          : const::intType,
                                isConstant    : true,
                                isNamed       : false,
                                isArgument    : false,
                                isGlobalConst : false
                            }
                        ],
                        codeData, compiledData, values, false, false, ir
                    )
                }
                value.runtimeTypesCompatibleCheck(types[index], codeData, compiledData, values, ir)
                values.addItem(value)
        if !allValues.named?()
            allValues.freeOperand(codeData, compiledData, ir)
        var valueIndex Int = allValues.named?().select(0, 1)
        parse index, name Token = names
            if name[0] != '_'
                const value Operand = values[valueIndex]
                const type COType = types[index]
                valueIndex++
                const variable String = codeData.newVariable()
                irStore(const::objectIRType, value.value~(), variable, "8", ir)
                var namedOperands Map = codeData.namedOperands`(Map())
                if !namedOperands.put(name.text~(), NamedOperand{{
                    level   : codeData.level~(),
                    operand : Operand{
                        code          : name,
                        access        : Access[write],
                        value         : variable,
                        type          : type,
                        isConstant    : false,
                        isNamed       : true,
                        isArgument    : false,
                        isGlobalConst : false
                    },
                    isUsed  : false
                }}).nothing?()
                    errorAlreadyExist(name, "variable")
                codeData.namedOperands`(namedOperands)
    else
        const name Token = block.getLowercaseName(tokenIndex, "variable")
        switch name.text~()
        case "var", "const", "for", "do", "parse", "gParse", "if", "elif", "select", "super", "true", "false", "switch", "tSwitch", "eSwitch", "case", "default", "fallthrough", "nothing"
            errorInvalidName(name, "variable")
        const type COType = block.getOperandType(tokenIndex, !codeData.allThisGroups~().empty?()).compileOType(compiledData)
        block.next!(tokenIndex, ["="])
        const value Operand = block.getExpression(tokenIndex).compileExpression(type, codeData, compiledData, [], ir).toReadOnly(codeData, ir)
        block.eol!(tokenIndex)
        if value.named?()
            value.useOperand(codeData, compiledData, ir)
        const variable String = codeData.newVariable()
        irStore(const::objectIRType, value.value~(), variable, "8", ir)
        var namedOperands Map = codeData.namedOperands`(Map())
        if !namedOperands.put(name.text~(), NamedOperand{{
            level   : codeData.level~(),
            operand : Operand{
                code          : name,
                access        : Access[write],
                value         : variable,
                type          : type,
                isConstant    : false,
                isNamed       : true,
                isArgument    : false,
                isGlobalConst : false
            },
            isUsed  : false
        }}).nothing?()
            errorAlreadyExist(name, "variable")
        codeData.namedOperands`(namedOperands)

// The function compiles the code that is executed if the function can return an error.
def compileInThrow(block Block, write codeData CodeData, compiledData CData, write ir String)
    block.subBlocks!()
    block.eol!(1)
    var tmpIR String = ""
    irCheckBegin(ir, false)
    codeData.level`(codeData.level~() + 1)
    const lastIsTerminator Bool = compileCode(block.subBlocks~(), codeData, compiledData, tmpIR)
    if lastIsTerminator
        const beginLabel String = codeData.createLabel()
        const endLabel String = codeData.createLabel()
        irIf("1", Expectation[unknown], beginLabel, endLabel, codeData, ir)
        irLabel(beginLabel, ir)
        ir += tmpIR
        irLabel(endLabel, ir)
    else
        ir += tmpIR
        codeData.freeLevel(codeData.level~(), compiledData, ir)
    codeData.deleteLevel(codeData.level~())
    irCheckEnd(ir, false)

// The function assigns a new value to an existing variable.
def compileVariableSet(block Block, write codeData CodeData, compiledData CData, write ir String)
    block.noSubBlocks!()
    var tokenIndex Int = 0
    const variableName Token = block.getLowercaseName(tokenIndex, "variable")
    const variableOperand <>NamedOperand = codeData.namedOperands~()[variableName.text~()]
    if variableOperand.nothing?() || variableOperand.operand~().access~() != Access[write]
        errorNotFound(variableName, "variable")
    codeData.markVariableAsChanged(variableName.text~())
    tokenIndex++
    const variableValue Operand = block.getExpression(tokenIndex).compileExpression(variableOperand.operand~().type~(), codeData, compiledData, [], ir).toReadOnly(codeData, ir)
    block.eol!(tokenIndex)
    if variableValue.code~() == variableName
        warningVarSetItself(variableName)
        return
    if variableValue.named?()
        variableValue.useOperand(codeData, compiledData, ir)
    variableOperand.operand~().freeOperand(codeData, compiledData, ir)
    irStore(const::objectIRType, variableValue.value~(), variableOperand.operand~().value~(), "8", ir)
