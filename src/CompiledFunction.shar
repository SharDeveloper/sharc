module Main

// Compiled function.
type CFunction
    // export? Bool
    // fullName String
    // finalFunction SimpleFunction | GroupsFunctions

attach CFunction to FieldExport
    #alwaysinline
    def export?(function CFunction) Bool
        return function.typeGetItem(0)

    #alwaysinline
    def export`(write function CFunction, new Bool) Bool
        return function.typePut(0, new)

attach CFunction to FieldFullName
    #alwaysinline
    def fullName~(function CFunction) String
        return function.typeGetItem(1)

    #alwaysinline
    def fullName`(write function CFunction, new String) String
        return function.typePut(1, new)

attach CFunction to FieldFinalFunction
    #alwaysinline
    def finalFunction~(function CFunction) $Any
        return function.typeGetItem(2)

    #alwaysinline
    def finalFunction`(write function CFunction, new $Any) $Any
        return function.typePut(2, new)

#alwaysinline
def cFunction(isExport Bool, fullName String, finalFunction $Any) CFunction
    return CFunction.fromList({isExport, fullName, finalFunction})

#alwaysinline
def addFunctionToFunctionWithGroupsFunctions(write functionWithGroupFunctions CFunction, type String, function SimpleFunction)
    var groupsFunctions GroupsFunctions = functionWithGroupFunctions.finalFunction`(nothing)
    var functions Map = groupsFunctions.functions`(nothing)
    functions.put(type, function)
    groupsFunctions.functions`(functions)
    functionWithGroupFunctions.finalFunction`(groupsFunctions)

// The function calls the function with the specified name and arguments.
#noinline
def callFunction(functionName Token, arguments Array, write codeData CodeData, compiledData CData, freedOnError Array, needFreeArguments Bool, write llvmIR String) Operand
    const isSuperFunction Bool = functionName.text~() == "super"
    if isSuperFunction && codeData.defaultFunctionName~().empty?()
        errorNotFound(functionName, "function")
    const function CFunction = compiledData.getFunction(isSuperFunction.select(functionName.replaceText(codeData.defaultFunctionName~()), functionName), false)
    var argumentsFromSignature Array = []
    var resultType OType = OType.fromList({})
    var functionThisType OType = OType.fromList({})
    var functionIsNoThrow Bool = false
    var typedFunction Bool = false
    var haveFinalSignature Bool = false
    var isWorker Bool = false
    tSwitch :(switch) function.finalFunction~()
    case GroupsFunctions
        const groupsFunctions GroupsFunctions = function.finalFunction~()
        if isSuperFunction
            const signature FSignature = groupsFunctions.functions~()["+"].signature~()
            argumentsFromSignature = signature.arguments~()
            resultType = signature.resultType~()
            if arguments.length~() != argumentsFromSignature.length~()
                errorWrongNumberOfArguments(functionName)
            typedFunction = true
            haveFinalSignature = true
            functionThisType = oType(const::emptyToken.replaceText(codeData.thisTypeName~()), false)
            end switch
        var simpleFunction <>SimpleFunction = groupsFunctions.functions~()["-"]
        if simpleFunction.nothing?()
            simpleFunction = groupsFunctions.functions~()["+"]
        const signature FSignature = simpleFunction.signature~()
        argumentsFromSignature = signature.arguments~()
        resultType = signature.resultType~()
        if arguments.length~() != argumentsFromSignature.length~()
            errorWrongNumberOfArguments(functionName)
        var argumentsWithThisTypeIndexes Array = []
        parse index, argument = argumentsFromSignature
            if argument.type~().this?()
                argumentsWithThisTypeIndexes.addItem(index)
        var thisIndexInArguments Int = -1
        parse :(parse) _, index = argumentsWithThisTypeIndexes
            const argument Operand = arguments[index]
            if argument.type~().simple?() && !(argument.type~().nothingType?() && argumentsFromSignature[index].type~().optional?())
                thisIndexInArguments = index
                functionThisType = argument.type~()
                end parse
        if thisIndexInArguments == -1
            var groupsSet Set = Set.createEmpty()
            parse _, mainGroupName = groupsFunctions.groups~()
                parse _, subGroupName = compiledData.getGroup(const::emptyToken.replaceText(mainGroupName), true).subGroups~()
                    groupsSet.add(subGroupName)
                groupsSet.add(mainGroupName)
            var groupsArray Array = []
            parse _, groupName = groupsSet
                groupsArray.addItem(const::emptyToken.replaceText(groupName))
            groupsArray.sort(true)
            functionThisType = oType(groupsArray, false)
        else
            typedFunction = true
            haveFinalSignature = true
            if !functionThisType.this?()
                const thisType CType = compiledData.getType(functionThisType.type~(), true)
                parse _, groupName = groupsFunctions.groups~()
                    if !thisType.groups~()[groupName]
                        errorTypeNotInGroup(arguments[thisIndexInArguments].code~().replaceText(oTypeToToken(functionThisType, true).text~()), groupName)
                const overridedFunction <>SimpleFunction = groupsFunctions.functions~()[thisType.fullName~()]
                if !overridedFunction.nothing?()
                    const overridedSignature FSignature = overridedFunction.signature~()
                    argumentsFromSignature = overridedSignature.arguments~()
                    resultType = overridedSignature.resultType~()
                    functionIsNoThrow = overridedFunction.attributes~().nothrow?()
    case SimpleFunction
        haveFinalSignature = true
        const simpleFunction SimpleFunction = function.finalFunction~()
        const signature FSignature = simpleFunction.signature~()
        const attributes FAttributes = simpleFunction.attributes~()
        functionIsNoThrow = attributes.nothrow?()
        isWorker = attributes.worker?()
        argumentsFromSignature = signature.arguments~()
        resultType = signature.resultType~()
        if arguments.length~() != argumentsFromSignature.length~()
            errorWrongNumberOfArguments(functionName)
    default
        unreachable()
    if resultType.this?()
        resultType.type`(functionThisType.type~())
        if resultType.anyType?() || resultType.nothingType?()
            resultType.optional`(false)
    var memoryManagerFunction Bool = false
    switch function.fullName~()
    case "STD::shar__rc_free", "STD::shar__rc_use", "STD::shar__to_const"
        memoryManagerFunction = true
        typedFunction = typedFunction && !functionThisType.optional?()
    var functionCallIRCode String = function.fullName~()
    if typedFunction
        functionCallIRCode += "." + functionThisType.type~().text~()
    functionCallIRCode += "##("
    var code Token = functionName
    code.addChar('(')
    var assumes String = ""
    var notCheckArguments Bool = true
    if !arguments.empty?()
        parse index, argument = arguments
            code.addString(argument.code~().text~() + ", ")
            var argumentFromSignature FSArgument = argumentsFromSignature[index]
            if argumentFromSignature.type~().this?()
                var argumentFromSignatureType OType = argumentFromSignature.type`(nothing)
                argumentFromSignatureType.type`(functionThisType.type~())
                if argumentFromSignatureType.anyType?() || argumentFromSignatureType.nothingType?()
                    argumentFromSignatureType.optional`(false)
                argumentFromSignature.type`(argumentFromSignatureType)
            var argumentWithCorrectAccess Operand = Operand.fromList({})
            eSwitch argumentFromSignature.access~()
            case access_noread
                argumentWithCorrectAccess = argument.toNoRead(codeData, llvmIR)
            case access_read
                argumentWithCorrectAccess = argument.toReadOnly(codeData, llvmIR)
            case access_write
                if argument.access~() != enum::access_write
                    if argument.access~() == enum::access_read
                        errorWrongAccess(argument.code~(), "write", "noread")
                    else
                        errorWrongAccess(argument.code~(), "write", "read only")
                if argumentFromSignature.type~().optional?() && !(argument.type~().optional?() || argument.type~().anyType?() || argument.type~().nothingType?())
                    errorWrongAccess(argument.code~(), "optional write", "write")
                argumentWithCorrectAccess = argument
                parse anotherIndex, anotherArgument = arguments
                    if anotherIndex != index
                        if anotherArgument.named?() && anotherArgument.code~().text~() == argument.code~().text~() && argumentsFromSignature[anotherIndex].access~() != enum::access_noread
                            errorSameArgumentsInCall(anotherArgument.code~())
            default
                unreachable()
            if notCheckArguments
                const argumentFromSignatureType OType = argumentFromSignature.type~()
                const argumentType OType = argument.type~()
                if argumentFromSignatureType.simple?()
                    notCheckArguments = {
                        ((argumentFromSignatureType.typeEq?(argumentType, false) && (argumentFromSignatureType.optional?() || !argumentType.optional?())) ||
                        (argumentFromSignatureType.optional?() && argumentType.nothingType?()))
                    }
                elif haveFinalSignature
                    if argumentType.simple?()
                        if argumentType.this?()
                            notCheckArguments = argumentFromSignatureType.this?() && (argumentFromSignatureType.optional?() || !argumentType.optional?())
                        else
                            const argumentTypeGroups Set = compiledData.getType(argumentType.type~(), true).groups~()
                            parse :(parse) _, groupFromSignature = argumentFromSignatureType.type~()
                                notCheckArguments = argumentTypeGroups[groupFromSignature.text~()]
                                if !notCheckArguments
                                    end parse
                    else
                        parse :(signatureParse) _, groupFromSignature = argumentFromSignatureType.type~()
                            parse _, groupFromArgument = argumentType.type~()
                                if groupFromArgument == groupFromSignature
                                    next signatureParse
                                notCheckArguments = false
                                end signatureParse
                else
                    notCheckArguments = false
            argument.typesCompatibleCheck(argumentFromSignature.type~(), codeData, compiledData)
            if argumentWithCorrectAccess.type~().simple?() && !argumentWithCorrectAccess.Main::constant?()
                var typeRegister String = ""
                if argumentWithCorrectAccess.access~() == enum::access_write
                    const typePointerRegister String = codeData.createRegister("getelementptr [2 x i64], [2 x i64]* " + argumentWithCorrectAccess.value~() + ", i64 0, i32 0", assumes)
                    typeRegister = codeData.createRegister("load i64, i64* " + typePointerRegister + ", align 8", assumes)
                else
                    typeRegister = codeData.createRegister("extractvalue [2 x i64] " + argumentWithCorrectAccess.value~() + ", 0", assumes)
                var trueRegister String = codeData.createRegister("icmp eq i64 " + typeRegister + ", ##tnum##" + oTypeToToken(argumentWithCorrectAccess.type~(), false).text~() + "##", assumes)
                if argumentWithCorrectAccess.type~().optional?()
                    const isNothingRegister String = codeData.createRegister("icmp eq i64 " + typeRegister + ", 0", assumes)
                    trueRegister = codeData.createRegister("or i1 " + trueRegister + ", " + isNothingRegister, assumes)
                assumes += "\tcall void @llvm.assume(i1 " + trueRegister + ")\n"
            functionCallIRCode += (argumentFromSignature.access~() == enum::access_write).select("[2 x i64]* ", "[2 x i64] ") + argumentWithCorrectAccess.value~() + ", "
        functionCallIRCode.delete(functionCallIRCode.length~() - 2, 2)
        var codeText String = code.text`("")
        codeText.delete(codeText.length~() - 2, 2)
        code.text`(codeText)
    var functionCallPrefix String = ""
    if (codeData.ownerNoThrow~() && codeData.catchLabels~().empty?()) || (functionIsNoThrow && notCheckArguments) || memoryManagerFunction
        functionCallPrefix = isSuperFunction.select("ancntfunc##!", "ancntfunc##")
    elif notCheckArguments
        functionCallPrefix = isSuperFunction.select("ancfunc##!", "ancfunc##")
    elif functionIsNoThrow
        functionCallPrefix = isSuperFunction.select("ntfunc##!", "ntfunc##")
    else
        functionCallPrefix = isSuperFunction.select("func##!", "func##")
    llvmIR += assumes
    if isWorker
        llvmIR += {
            "\tcall void @shar__create__worker([2 x i64] ([2 x i64], [2 x i64])* ##" + functionCallPrefix + function.fullName~() +
            "##, [2 x i64] " + arguments[0].toReadOnly(codeData, llvmIR).value~() +
            ", [2 x i64] " + arguments[1].toReadOnly(codeData, llvmIR).value~() +
            ", [2 x i64] ([2 x i64])* ##ancntfunc##STD::shar__rc_free##)\n"
        }
    code.addChar(')')
    const result Operand = operand{
        (code, enum::access_read,
        isWorker.select
            ("zeroinitializer",
            codeData.createRegister("call [2 x i64] ##" + functionCallPrefix + functionCallIRCode + ")", llvmIR)),
        resultType, false, true, false, false, false)
    }
    if needFreeArguments
        parse index, argument = arguments
            if !argument.named?()
                var mutArgument Operand = argument
                var argumentFromSignatureType OType = argumentsFromSignature[index].type~()
                if argumentFromSignatureType.this?()
                    argumentFromSignatureType = functionThisType
                if argumentFromSignatureType.simple?() && !mutArgument.type~().simple?()
                    mutArgument.type`(argumentFromSignatureType)
                mutArgument.freeOperand(codeData, compiledData, llvmIR)
    if !memoryManagerFunction
        result.checkOperandForError(codeData, compiledData, freedOnError, llvmIR)
    return result

// The function generates code that checks the type of function arguments.
def runtimeCheckFunctionArguments(arguments Array, write codeData CodeData, write llvmIR String)
    var resultI1 String = ""
    parse index, argument = arguments
        if !argument.type~().anyType?()
            var argumentTypeRegister String = ""
            const indexAsString String = index.toString()
            if argument.access~() == enum::access_write
                const pointerRegister String = codeData.createRegister("getelementptr [2 x i64], [2 x i64]* %" + indexAsString + ", i64 0, i32 0", llvmIR)
                argumentTypeRegister = codeData.createRegister("load i64, i64* " + pointerRegister + ", align 8", llvmIR)
            else
                const typeRegister String = codeData.createRegister("extractvalue [2 x i64] %" + indexAsString + ", 0", llvmIR)
                argumentTypeRegister = typeRegister
            const typeAsString String = oTypeToToken(argument.type~(), false).text~()
            const typeIsCorrectRegisterValue String = argument.type~().simple?().select{
                ("icmp eq i64 " + argumentTypeRegister + ", ##tnum##" + typeAsString + "##",
                "call i1 ##ingroups##" + typeAsString[2 : typeAsString.length~() - 1] + "##(i64 " + argumentTypeRegister + ")")
            }
            var typeIsCorrectRegister String = codeData.createRegister(typeIsCorrectRegisterValue, llvmIR)
            if argument.type~().optional?()
                const typeIsNothingRegister String = codeData.createRegister("icmp eq i64 " + argumentTypeRegister + ", 0", llvmIR)
                typeIsCorrectRegister = codeData.createRegister("or i1 " + typeIsCorrectRegister + ", " + typeIsNothingRegister, llvmIR)
            resultI1 = resultI1.empty?().select(typeIsCorrectRegister, codeData.createRegister("and i1 " + resultI1 + ", " + typeIsCorrectRegister, llvmIR))
    if !resultI1.empty?()
        const allOkRegister String = resultI1.likelyI1Register(codeData, llvmIR)
        const allOkLabel String = codeData.createLabel()
        const invalidTypeErrorLabel String = codeData.createLabel()
        const checkLabel String = codeData.createLabel()
        llvmIR = {
            "\tbr i1 ##flag##arguments!##, label %##reg##" + checkLabel + "##, label %##reg##" + allOkLabel + "##\n"
            "\t##nreg##" + checkLabel + "##:\n" +
            llvmIR +
            "\tbr i1 " + allOkRegister + ", label %##reg##" + allOkLabel + "##, label %##reg##" + invalidTypeErrorLabel + "##\n"
            "\t##nreg##" + invalidTypeErrorLabel + "##:\n"
        }
        llvmIR += "\tret [2 x i64] " + createError("0", "Invalid type.\\n<- " + codeData.functionNameForErrorMessage~()) + "\n\t##nreg##" + allOkLabel + "##:\n"

// The function generates llvm ir code for a function.
def functionToFinalLLVMIR(compiledData CData, functionAndTypeName Token, write compilingConstants, write compilingFunctions Set, write usedData UsedData)
    if !usedData.functions~()[functionAndTypeName.text~()].nothing?()
        return
    if !functionAndTypeName.text~().containPart?("::")
        errorNotFound(functionAndTypeName, "function")
    const separatorIndex <>Int = functionAndTypeName.text~().look('.')
    const isSuperFunction Bool = functionAndTypeName[0] == '!'
    const nameStartIndex Int = isSuperFunction.select(1, 0)
    const functionName Token = functionAndTypeName.replaceText{
        (separatorIndex.nothing?().select(
            functionAndTypeName.text~()[nameStartIndex : functionAndTypeName.text~().length~() - 2],
            functionAndTypeName.text~()[nameStartIndex : separatorIndex]
        ))
    }
    const typeName Token = separatorIndex.nothing?().select{
        (const::emptyToken,
        functionAndTypeName.replaceText(functionAndTypeName.text~()[separatorIndex + 1 : functionAndTypeName.text~().length~() - 2]))
    }
    const functionVariant String = functionAndTypeName.text~()[functionAndTypeName.text~().length~() - 2 : functionAndTypeName.text~().length~()]
    const function CFunction = compiledData.getFunction(functionName, true)
    var simpleFunction SimpleFunction = SimpleFunction.fromList({})
    tSwitch function.finalFunction~()
    case SimpleFunction
        if !typeName.empty?()
            errorNotFound(functionAndTypeName, "function")
        simpleFunction = function.finalFunction~()
    case GroupsFunctions
        const groupsFunctions GroupsFunctions = function.finalFunction~()
        if typeName.empty?()
            const groups Array = groupsFunctions.groups~()
            var groupsListAsString String = groups[0]
            do
                var usedGroupsFunctions Map = usedData.groupsFunctions`(nothing)
                usedGroupsFunctions.put(functionName.text~() + functionVariant, groups)
                usedData.groupsFunctions`(usedGroupsFunctions)
                var typesInGroups Set = usedData.groupsTypes~()[groupsListAsString /*groups[0]*/]
                for :(groupIndex Int = 1) groupIndex < groups.length~(); groupIndex++
                    const currentGroupName String = groups[groupIndex]
                    const currentGroupTypes Set = usedData.groupsTypes~()[currentGroupName]
                    groupsListAsString += "," + currentGroupName
                    parse _, alreadyInTypeName = typesInGroups
                        if !currentGroupTypes[alreadyInTypeName]
                            typesInGroups.remove(alreadyInTypeName)
                parse _, typeInGroup = typesInGroups
                    const fullFunctionName String = functionName.text~() + "." + typeInGroup + functionVariant
                    compilingFunctions.add(const::emptyToken.replaceText(fullFunctionName))
                const maybeSimpleFunction <>SimpleFunction = groupsFunctions.functions~()["-"]
                simpleFunction = maybeSimpleFunction.nothing?().select(groupsFunctions.functions~()["+"], maybeSimpleFunction)
            var llvmFunctionSignature String = "define private [2 x i64] " + createFunctionLLVMName(functionName.text~(), "", functionVariant[0] == '1', functionVariant[1] == '1', false) + "("
            var llvmFunctionType String = "[2 x i64] ("
            var thisTypeArgumentIndex Int = -1
            parse index, argument = simpleFunction.signature~().arguments~()
                if argument.type~().this?() && !argument.type~().optional?()
                    if thisTypeArgumentIndex == -1
                        thisTypeArgumentIndex = index
                    elif argument.access~() != enum::access_write && simpleFunction.signature~().arguments~()[thisTypeArgumentIndex].access~() == enum::access_write
                        thisTypeArgumentIndex = index
                llvmFunctionType += (argument.access~() == enum::access_write).select("[2 x i64]* noalias, ", "[2 x i64], ")
            const thisTypeArgumentIsMutable String = (simpleFunction.signature~().arguments~()[thisTypeArgumentIndex].access~() == enum::access_write).select("1", "0")
            llvmFunctionType.delete(llvmFunctionType.length~() - 2, 2)
            llvmFunctionSignature += llvmFunctionType[11 : llvmFunctionType.length~()]
            var usedFunctions Map = usedData.functions`(nothing)
            usedFunctions.put(isSuperFunction.select(functionAndTypeName.text~()[1 : functionAndTypeName.text~().length~()], functionAndTypeName.text~()), "|" + thisTypeArgumentIndex.toString() + "|" + (simpleFunction.signature~().arguments~().length~() + 1).toString() + "|" + groupsListAsString + "|" + llvmFunctionType + ")*|" + llvmFunctionSignature + ") nounwind {\n|" + thisTypeArgumentIsMutable)
            usedData.functions`(usedFunctions)
            return
        if !typeName.text~().containPart?("::")
            errorNotFound(typeName, "type")
        compiledData.getType(typeName, true)
        if isSuperFunction
            simpleFunction = groupsFunctions.functions~()["+"]
        else
            var maybeSimpleFunction <>SimpleFunction = groupsFunctions.functions~()[typeName.text~()]
            if maybeSimpleFunction.nothing?()
                maybeSimpleFunction = groupsFunctions.functions~()["+"]
                if maybeSimpleFunction.nothing?()
                    errorNotFound(functionAndTypeName, "function")
            simpleFunction = maybeSimpleFunction
    var llvmFunction String = "define private [2 x i64] " + createFunctionLLVMName(functionName.text~(), typeName.text~(), functionVariant[0] == '1', functionVariant[1] == '1', isSuperFunction) + "("
    if !simpleFunction.signature~().arguments~().empty?()
        parse _, argument = simpleFunction.signature~().arguments~()
            llvmFunction += (argument.access~() == enum::access_write).select("[2 x i64]* noalias, ", "[2 x i64], ")
        llvmFunction.delete(llvmFunction.length~() - 2, 2)
    var inlineAttribute String = ""
    const attributes FAttributes = simpleFunction.attributes~()
    if attributes.alwaysInline?()
        inlineAttribute = ") alwaysinline nounwind{\n"
    elif attributes.inline?()
        inlineAttribute = ") inlinehint nounwind{\n"
    elif attributes.noInline?()
        inlineAttribute = ") noinline nounwind{\n"
    elif attributes.cold?()
        inlineAttribute = ") cold nounwind{\n"
    else
        inlineAttribute = ") nounwind{\n"
    llvmFunction += inlineAttribute + toFinalLLVMIR(simpleFunction.llvmIR~(), functionAndTypeName, compiledData, typeName.text~(), compilingConstants, compilingFunctions, usedData, functionVariant[0] == '1', functionVariant[1] == '1') + "}\n\n"
    var usedFunctions Map = usedData.functions`(nothing)
    usedFunctions.put(functionAndTypeName.text~(), llvmFunction)
    usedData.functions`(usedFunctions)
