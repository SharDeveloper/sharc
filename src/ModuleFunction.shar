module Main

// A function inside a module.
type ModuleFunction
    // export?        Bool
    // name           String
    // module         String
    // owningGroups   [String]
    // thisType       String
    // finalFunction  SimpleFunction

attach ModuleFunction to FieldExport
    #alwaysinline
    def export?(function ModuleFunction) Bool
        return function.typeGetItem(0)

    #alwaysinline
    def export`(write function ModuleFunction, new Bool) Bool
        return function.typePut(0, new)

attach ModuleFunction to FieldName
    #alwaysinline
    def name~(function ModuleFunction) String
        return function.typeGetItem(1)

    #alwaysinline
    def name`(write function ModuleFunction, new String) String
        return function.typePut(1, new)

attach ModuleFunction to FieldModule
    #alwaysinline
    def module~(function ModuleFunction) String
        return function.typeGetItem(2)

    #alwaysinline
    def module`(write function ModuleFunction, new String) String
        return function.typePut(2, new)

attach ModuleFunction to FieldOwningGroups
    #alwaysinline
    def owningGroups~(function ModuleFunction) Array
        return function.typeGetItem(3)

    #alwaysinline
    def owningGroups`(write function ModuleFunction, new Array) Array
        return function.typePut(3, new)

attach ModuleFunction to FieldThisType
    #alwaysinline
    def thisType~(function ModuleFunction) String
        return function.typeGetItem(4)

    #alwaysinline
    def thisType`(write function ModuleFunction, new String) String
        return function.typePut(4, new)

attach ModuleFunction to FieldFinalFunction
    #alwaysinline
    def finalFunction~(function ModuleFunction) SimpleFunction
        return function.typeGetItem(5)

    #alwaysinline
    def finalFunction`(write function ModuleFunction, new <>SimpleFunction) <>SimpleFunction
        return function.typePut(5, new)

#alwaysinline
def ModuleFunction(isExport Bool, name, module String, groups Array, thisType String, finalFunction SimpleFunction) ModuleFunction
    return ModuleFunction.fromList({isExport, name, module, groups, thisType, finalFunction})

attach ModuleFunction to BinarySerializable
    #alwaysinline
    def serialize(function ModuleFunction, write bytes Bytes)
        const isExport Bool = function.export?()
        const name String = function.name~()
        const module String = function.module~()
        const groups Array = function.owningGroups~()
        const thisType String = function.thisType~()
        const finalFunction SimpleFunction = function.finalFunction~()
        isExport.serialize(bytes)
        name.serialize(bytes)
        module.serialize(bytes)
        groups.length~().serialize(bytes)
        parse _, group = groups
            group.serialize(bytes)
        thisType.serialize(bytes)
        finalFunction.serialize(bytes)

    #alwaysinline
    def deserialize(noread type ModuleFunction, bytes Bytes, write position Int) ModuleFunction
        const startPosition Int = position
        try
            const isExport Bool = Bool.deserialize(bytes, position)
            const name String = String.deserialize(bytes, position)
            const module String = String.deserialize(bytes, position)
            const length Int = Int.deserialize(bytes, position)
            var groups Array = []
            for :(index Int = 0) index < length; index++
                groups.addItem(String.deserialize(bytes, position))
            const thisType String = String.deserialize(bytes, position)
            const finalFunction SimpleFunction = SimpleFunction.deserialize(bytes, position)
            return ModuleFunction(isExport, name, module, groups, thisType, finalFunction)
        catch id, message, data
            position = startPosition
            throw(id, message, data)
