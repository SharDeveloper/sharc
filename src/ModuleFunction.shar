module Main

// A function inside a module.
type ModuleFunction
    // export?        Bool
    // name           String
    // module         String
    // owningGroup    String
    // thisType       String
    // finalFunction  SimpleFunction

attach ModuleFunction to FieldExport
    #alwaysinline
    def export?(function ModuleFunction) Bool
        return function.typeGetItem(0)

    #alwaysinline
    def export`(write function ModuleFunction, new Bool) Bool
        return function.typePut(0, new)

attach ModuleFunction to FieldName
    #alwaysinline
    def name~(function ModuleFunction) String
        return function.typeGetItem(1)

    #alwaysinline
    def name`(write function ModuleFunction, new String) String
        return function.typePut(1, new)

attach ModuleFunction to FieldModule
    #alwaysinline
    def module~(function ModuleFunction) String
        return function.typeGetItem(2)

    #alwaysinline
    def module`(write function ModuleFunction, new String) String
        return function.typePut(2, new)

attach ModuleFunction to FieldOwningGroup
    #alwaysinline
    def owningGroup~(function ModuleFunction) String
        return function.typeGetItem(3)

    #alwaysinline
    def owningGroup`(write function ModuleFunction, new String) String
        return function.typePut(3, new)

attach ModuleFunction to FieldThisType
    #alwaysinline
    def thisType~(function ModuleFunction) String
        return function.typeGetItem(4)

    #alwaysinline
    def thisType`(write function ModuleFunction, new String) String
        return function.typePut(4, new)

attach ModuleFunction to FieldFinalFunction
    #alwaysinline
    def finalFunction~(function ModuleFunction) SimpleFunction
        return function.typeGetItem(5)

    #alwaysinline
    def finalFunction`(write function ModuleFunction, new <>SimpleFunction) <>SimpleFunction
        return function.typePut(5, new)

#alwaysinline
def moduleFunction(isExport Bool, name, module, group, thisType String, finalFunction SimpleFunction) ModuleFunction
    return ModuleFunction.fromList({isExport, name, module, group, thisType, finalFunction})

attach ModuleFunction to BinarySerializable
    #alwaysinline
    def serialize(function ModuleFunction, write bytes Bytes)
        const isExport Bool = function.export?()
        const name String = function.name~()
        const module String = function.module~()
        const group String = function.owningGroup~()
        const thisType String = function.thisType~()
        const finalFunction SimpleFunction = function.finalFunction~()
        isExport.serialize(bytes)
        name.serialize(bytes)
        module.serialize(bytes)
        group.serialize(bytes)
        thisType.serialize(bytes)
        finalFunction.serialize(bytes)

    #alwaysinline
    def deserialize(noread type ModuleFunction, bytes Bytes, write position Int) ModuleFunction
        const startPosition Int = position
        try
            const isExport Bool = Bool.deserialize(bytes, position)
            const name String = String.deserialize(bytes, position)
            const module String = String.deserialize(bytes, position)
            const group String = String.deserialize(bytes, position)
            const thisType String = String.deserialize(bytes, position)
            const finalFunction SimpleFunction = SimpleFunction.deserialize(bytes, position)
            return moduleFunction(isExport, name, module, group, thisType, finalFunction)
        catch id, message
            position = startPosition
            throw(id, message)
