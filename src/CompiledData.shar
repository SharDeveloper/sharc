module Main

// Compiled data.
type CData
    // currentModule        String
    // enumerationsElements Map(name String, Map(moduleName String, isExport Bool))
    // constants            Map(name String, Map(moduleName String, CConstant))
    // types                Map(name String, Map(moduleName String, CType))
    // groups               Map(name String, Map(moduleName String, CGroup))
    // functions            Map(name String, Map(moduleName String, CFunction))

def moduleSignature() Bytes
    var result Bytes = Bytes.createEmpty()
    parse _, char = "shar module 0.2|"
        result.addItem(charToInt(char))
    return result

attach CData to FieldCurrentModule
    #alwaysinline
    def currentModule~(data CData) String
        return data.typeGetItem(0)

    #alwaysinline
    def currentModule`(write data CData, new String) String
        return data.typePut(0, new)

attach CData to FieldEnumerationsElements
    #alwaysinline
    def enumerationsElements~(data CData) Map
        return data.typeGetItem(1)

    #alwaysinline
    def enumerationsElements`(write data CData, new <>Map) <>Map
        return data.typePut(1, new)

attach CData to FieldConstants
    #alwaysinline
    def constants~(data CData) Map
        return data.typeGetItem(2)

    #alwaysinline
    def constants`(write data CData, new <>Map) <>Map
        return data.typePut(2, new)

attach CData to FieldTypes
    #alwaysinline
    def types~(data CData) Map
        return data.typeGetItem(3)

    #alwaysinline
    def types`(write data CData, new <>Map) <>Map
        return data.typePut(3, new)

attach CData to FieldGroups
    #alwaysinline
    def groups~(data CData) Map
        return data.typeGetItem(4)

    #alwaysinline
    def groups`(write data CData, new <>Map) <>Map
        return data.typePut(4, new)

attach CData to FieldFunctions
    #alwaysinline
    def functions~(data CData) Map
        return data.typeGetItem(5)

    #alwaysinline
    def functions`(write data CData, new <>Map) <>Map
        return data.typePut(5, new)

#alwaysinline
def cData(currentModule String, enumerationsElements, constants, types, groups, functions Map) CData
    return CData.fromList({currentModule, enumerationsElements, constants, types, groups, functions})

// The function loads data from modules into compiled data.
def loadModules(modulesFilesList Array, currentModule String) CData
    var enumerationsElements Map = Map.createEmpty()
    var constants Map = Map.createEmpty()
    var types Map = Map.createEmpty()
    var groups Map = Map.createEmpty()
    var functions Map = Map.createEmpty()
    var loadedModules Map = Map.createEmpty()
    const moduleSignature Bytes = moduleSignature()
    parse _, moduleFileName = modulesFilesList
        var position Int = moduleSignature.length~()
        var module <>Bytes = loadFile(moduleFileName)
        if module.nothing?()
            errorCanNotLoadFile(moduleFileName)
        if !module.hasPrefix?(moduleSignature)
            errorNotModule(moduleFileName)
        const moduleName String = String.deserialize(module, position)
        if moduleName.empty?()
            errorNotModule(moduleFileName)
        const fileNameWithSameModule <>String = loadedModules.put(moduleName, moduleFileName)
        if !fileNameWithSameModule.nothing?()
            error2Module1Name(fileNameWithSameModule, moduleFileName, moduleName)
        try
            var length Int = Int.deserialize(module, position)
            for :(counter Int = 0) counter < length; counter++
                const elementName String = String.deserialize(module, position)
                const isExport Bool = Bool.deserialize(module, position)
                var allElementsWithSameName <>Map = enumerationsElements.put(elementName, Map.createEmpty())
                if allElementsWithSameName.nothing?()
                    allElementsWithSameName = Map.createEmpty()
                allElementsWithSameName.put(moduleName, isExport)
                enumerationsElements.put(elementName, allElementsWithSameName)
            length = Int.deserialize(module, position)
            for :(counter Int = 0) counter < length; counter++
                var constant CConstant = CConstant.deserialize(module, position)
                const constantName String = constant.fullName~()
                constant.fullName`(moduleName + "::" + constantName)
                var allConstantsWithSameName <>Map = constants.put(constantName, Map.createEmpty())
                if allConstantsWithSameName.nothing?()
                    allConstantsWithSameName = Map.createEmpty()
                allConstantsWithSameName.put(moduleName, constant)
                constants.put(constantName, allConstantsWithSameName)
            length = Int.deserialize(module, position)
            for :(counter Int = 0) counter < length; counter++
                var type CType = CType.deserialize(module, position)
                const typeName String = type.fullName~()
                type.fullName`(moduleName + "::" + typeName)
                var allTypesWithSameName <>Map = types.put(typeName, Map.createEmpty())
                if allTypesWithSameName.nothing?()
                    allTypesWithSameName = Map.createEmpty()
                allTypesWithSameName.put(moduleName, type)
                types.put(typeName, allTypesWithSameName)
            length = Int.deserialize(module, position)
            for :(counter Int = 0) counter < length; counter++
                var group CGroup = CGroup.deserialize(module, position)
                const groupName String = group.fullName~()
                group.fullName`(moduleName + "::" + groupName)
                var allGroupsWithSameName <>Map = groups.put(groupName, Map.createEmpty())
                if allGroupsWithSameName.nothing?()
                    allGroupsWithSameName = Map.createEmpty()
                allGroupsWithSameName.put(moduleName, group)
                groups.put(groupName, allGroupsWithSameName)
            length = Int.deserialize(module, position)
            for :(counter Int = 0) counter < length; counter++
                const function ModuleFunction = ModuleFunction.deserialize(module, position)
                const functionName String = function.name~()
                const functionModule String = function.module~()
                var allFunctionsWithSameName <>Map = functions.put(functionName, Map.createEmpty())
                var newFunction CFunction = CFunction.fromList({})
                if allFunctionsWithSameName.nothing?()
                    allFunctionsWithSameName = Map.createEmpty()
                if function.owningGroup~().empty?()
                    const cFunction CFunction = cFunction(function.export?(), functionModule + "::" + functionName, function.finalFunction~())
                    newFunction = cFunction
                else
                    var groupFunctions <>CFunction = allFunctionsWithSameName[functionModule]
                    if groupFunctions.nothing?()
                        groupFunctions = cFunction(function.export?(), functionModule + "::" + functionName, groupFunctions(function.owningGroup~(), Map.createEmpty()))
                    addFunctionToFunctionWithGroupsFunctions(groupFunctions, function.thisType~(), function.finalFunction~())
                    newFunction = groupFunctions
                allFunctionsWithSameName.put(functionModule, newFunction)
                functions.put(functionName, allFunctionsWithSameName)
        catch
            errorNotModule(moduleFileName)
    return cData(currentModule, enumerationsElements, constants, types, groups, functions)

// The function returns the type with the specified name.
def getType(compiledData CData, typeName Token, ignoreExport Bool) CType
    var shortTypeName String = typeName.text~()
    const separatorIndex <>Int = shortTypeName.lookPart("::")
    if !separatorIndex.nothing?()
        shortTypeName = shortTypeName[separatorIndex +  2 : shortTypeName.length~()]
    const allTypesWithSameName <>Map = compiledData.types~()[shortTypeName]
    if !allTypesWithSameName.nothing?()
        if separatorIndex.nothing?()
            var type CType = CType.fromList({})
            parse moduleName, typeWithDesiredName = allTypesWithSameName
                if typeWithDesiredName.export?() || moduleName == compiledData.currentModule~()
                    if type.toList().empty?()
                        type = typeWithDesiredName
                    else
                        errorFewVariants(typeName, "types", type.fullName~().splitByPart("::")[0], moduleName)
            if !type.toList().empty?()
                return type
        else
            const moduleName String = typeName.text~()[0 : separatorIndex]
            const type <>CType = allTypesWithSameName[moduleName]
            if !type.nothing?() && (ignoreExport || type.export?() || moduleName == compiledData.currentModule~())
                return type
    errorNotFound(typeName, "type")

// The function returns a type with the specified name, and puts a dummy in its place.
def borrowType(write compiledData CData, typeName Token) CType
    var shortTypeName String = typeName.text~()
    const separatorIndex <>Int = shortTypeName.lookPart("::")
    if !separatorIndex.nothing?()
        shortTypeName = shortTypeName[separatorIndex +  2 : shortTypeName.length~()]
    var allTypes Map = compiledData.types`(nothing)
    var allTypesWithSameName <>Map = allTypes.put(shortTypeName, Map.createEmpty())
    var type <>CType = nothing
    if !allTypesWithSameName.nothing?()
        if separatorIndex.nothing?()
            var foundedTypeModuleName String = ""
            parse moduleName, typeWithDesiredName = allTypesWithSameName
                if typeWithDesiredName.export?() || moduleName == compiledData.currentModule~()
                    if foundedTypeModuleName.empty?()
                        foundedTypeModuleName = moduleName
                    else
                        errorFewVariants(typeName, "types", foundedTypeModuleName, moduleName)
            if !foundedTypeModuleName.empty?()
                type = allTypesWithSameName.put(foundedTypeModuleName, CType.fromList({}))
        else
            const moduleName String = typeName.text~()[0 : separatorIndex]
            type = allTypesWithSameName.put(moduleName, CType.fromList({}))
            if !type.nothing?() && !(type.export?() || moduleName == compiledData.currentModule~())
                type = nothing
    if type.nothing?()
        errorNotFound(typeName, "type")
    allTypes.put(shortTypeName, allTypesWithSameName)
    compiledData.types`(allTypes)
    return type

// The function returns back the type that was obtained using the "borrowType" function.
def refitType(write compiledData CData, type CType)
    const splitedName Array = type.fullName~().splitByPart("::")
    const moduleName String = splitedName[0]
    const typeName String = splitedName[1]
    var allTypes Map = compiledData.types`(nothing)
    var allTypesWithSameName Map = allTypes.put(typeName, Map.createEmpty())
    allTypesWithSameName.put(moduleName, type)
    allTypes.put(typeName, allTypesWithSameName)
    compiledData.types`(allTypes)

// The function returns a group with the specified name.
def getGroup(compiledData CData, groupName Token, ignoreExport Bool) CGroup
    var shortGroupName String = groupName.text~()
    const separatorIndex <>Int = shortGroupName.lookPart("::")
    if !separatorIndex.nothing?()
        shortGroupName = shortGroupName[separatorIndex +  2 : shortGroupName.length~()]
    const allGroupsWithSameName <>Map = compiledData.groups~()[shortGroupName]
    if !allGroupsWithSameName.nothing?()
        if separatorIndex.nothing?()
            var group CGroup = CGroup.fromList({})
            parse moduleName, groupWithDesiredName = allGroupsWithSameName
                if groupWithDesiredName.export?() || moduleName == compiledData.currentModule~()
                    if group.toList().empty?()
                        group = groupWithDesiredName
                    else
                        errorFewVariants(groupName, "groups", group.fullName~().splitByPart("::")[0], moduleName)
            if !group.toList().empty?()
                return group
        else
            const moduleName String = groupName.text~()[0 : separatorIndex]
            const group <>CGroup = allGroupsWithSameName[moduleName]
            if !group.nothing?() && (ignoreExport || group.export?() || moduleName == compiledData.currentModule~())
                return group
    errorNotFound(groupName, "group")

// The function adds a function that is declared in the group and must be defined when adding any type to this group.
#alwaysinline
def addRequiredFunction(write compiledData CData, group Group, function GFunction)
    var allFunctions Map = compiledData.functions`(nothing)
    var allFunctionsWithSameName <>Map = allFunctions.put(function.name~().text~(), Map.createEmpty())
    if allFunctionsWithSameName.nothing?()
        allFunctionsWithSameName = Map.createEmpty()
    var groupFunctions Map = Map.createEmpty()
    groupFunctions.put{
        ("-", sFunction(
            const::defaultFAttributes,
            function.signature~().toFull(compiledData),
            "",
            true
        ))
    }
    if !allFunctionsWithSameName.put{
        (compiledData.currentModule~(),
        cFunction(
            group.export?(),
            compiledData.currentModule~() + "::" + function.name~().text~(),
            groupFunctions(compiledData.currentModule~() + "::" + group.name~().text~(), groupFunctions)
        )).nothing?()
    }
        errorAlreadyExist(function.name~(), "function")
    allFunctions.put(function.name~().text~(), allFunctionsWithSameName)
    compiledData.functions`(allFunctions)

// The function returns a constant with the specified name.
def getConstant(compiledData CData, constantName Token, ignoreExport Bool) CConstant
    var shortConstantName String = constantName.text~()
    const separatorIndex <>Int = shortConstantName.lookPart("::")
    if !separatorIndex.nothing?()
        shortConstantName = shortConstantName[separatorIndex +  2 : shortConstantName.length~()]
    const allConstantsWithSameName <>Map = compiledData.constants~()[shortConstantName]
    if !allConstantsWithSameName.nothing?()
        if separatorIndex.nothing?()
            var constant CConstant = CConstant.fromList({})
            parse moduleName, constantWithDesiredName = allConstantsWithSameName
                if constantWithDesiredName.export?() || moduleName == compiledData.currentModule~()
                    if constant.toList().empty?()
                        constant = constantWithDesiredName
                    else
                        errorFewVariants(constantName, "constants", constant.fullName~().splitByPart("::")[0], moduleName)
            if !constant.toList().empty?()
                return constant
        else
            const moduleName String = constantName.text~()[0 : separatorIndex]
            const constant <>CConstant = allConstantsWithSameName[moduleName]
            if !constant.nothing?() && (ignoreExport || constant.export?() || moduleName == compiledData.currentModule~())
                return constant
    errorNotFound(constantName, "constant")

// The function returns the full name of the enumeration element.
def getEnumElementFullName(compiledData CData, elementName Token, ignoreExport Bool) String
    var shortElementName String = elementName.text~()
    const separatorIndex <>Int = shortElementName.lookPart("::")
    if !separatorIndex.nothing?()
        shortElementName = shortElementName[separatorIndex +  2 : shortElementName.length~()]
    const allElementsWithSameName <>Map = compiledData.enumerationsElements~()[shortElementName]
    if !allElementsWithSameName.nothing?()
        if separatorIndex.nothing?()
            var result String = ""
            parse moduleName, isExport = allElementsWithSameName
                if isExport || moduleName == compiledData.currentModule~()
                    if result.empty?()
                        result = moduleName + "::" + shortElementName
                    else
                        errorFewVariants(elementName, "elements", result.splitByPart("::")[0], moduleName)
            if !result.empty?()
                return result
        else
            const moduleName String = elementName.text~()[0 : separatorIndex]
            const isExport <>Bool = allElementsWithSameName[moduleName]
            if !isExport.nothing?() && (ignoreExport || isExport || moduleName == compiledData.currentModule~())
                return moduleName + "::" + shortElementName
    errorNotFound(elementName, "enumeration element")

// The function returns the function with the specified name.
def getFunction(compiledData CData, functionName Token, ignoreExport Bool) CFunction
    var shortFunctionName String = functionName.text~()
    const separatorIndex <>Int = shortFunctionName.lookPart("::")
    if !separatorIndex.nothing?()
        shortFunctionName = shortFunctionName[separatorIndex +  2 : shortFunctionName.length~()]
    const allFunctionsWithSameName <>Map = compiledData.functions~()[shortFunctionName]
    if !allFunctionsWithSameName.nothing?()
        if separatorIndex.nothing?()
            var function CFunction = CFunction.fromList({})
            parse moduleName, functionWithDesiredName = allFunctionsWithSameName
                if functionWithDesiredName.export?() || moduleName == compiledData.currentModule~()
                    if function.toList().empty?()
                        function = functionWithDesiredName
                    else
                        errorFewVariants(functionName, "functions", function.fullName~().splitByPart("::")[0], moduleName)
            if !function.toList().empty?()
                return function
        else
            const moduleName String = functionName.text~()[0 : separatorIndex]
            const function <>CFunction = allFunctionsWithSameName[moduleName]
            if !function.nothing?() && (ignoreExport || function.export?() || moduleName == compiledData.currentModule~())
                return function
    errorNotFound(functionName, "function")

// The function returns a function with the specified name, and puts a dummy in its place.
def borrowFunction(write compiledData CData, functionName Token) CFunction
    var shortFunctionName String = functionName.text~()
    const separatorIndex <>Int = shortFunctionName.lookPart("::")
    if !separatorIndex.nothing?()
        shortFunctionName = shortFunctionName[separatorIndex +  2 : shortFunctionName.length~()]
    var allFunctions Map = compiledData.functions`(nothing)
    var allFunctionsWithSameName <>Map = allFunctions.put(shortFunctionName, Map.createEmpty())
    var function <>CFunction = nothing
    if !allFunctionsWithSameName.nothing?()
        if separatorIndex.nothing?()
            var foundedFunctionModuleName String = ""
            parse moduleName, functionWithDesiredName = allFunctionsWithSameName
                if functionWithDesiredName.export?() || moduleName == compiledData.currentModule~()
                    if foundedFunctionModuleName.empty?()
                        foundedFunctionModuleName = moduleName
                    else
                        errorFewVariants(functionName, "functions", foundedFunctionModuleName, moduleName)
            if !foundedFunctionModuleName.empty?()
                function = allFunctionsWithSameName.put(foundedFunctionModuleName, CFunction.fromList({}))
        else
            const moduleName String = functionName.text~()[0 : separatorIndex]
            function = allFunctionsWithSameName.put(moduleName, CFunction.fromList({}))
            if !function.nothing?() && !(function.export?() || moduleName == compiledData.currentModule~())
                function = nothing
    if function.nothing?()
        errorNotFound(functionName, "function")
    allFunctions.put(shortFunctionName, allFunctionsWithSameName)
    compiledData.functions`(allFunctions)
    return function

// The function returns back the function that was obtained using the "borrowFunction" function.
def refitFunction(write compiledData CData, function CFunction)
    const splitedName Array = function.fullName~().splitByPart("::")
    const moduleName String = splitedName[0]
    const functionName String = splitedName[1]
    var allFunctions Map = compiledData.functions`(nothing)
    var allFunctionsWithSameName Map = allFunctions.put(functionName, Map.createEmpty())
    allFunctionsWithSameName.put(moduleName, function)
    allFunctions.put(functionName, allFunctionsWithSameName)
    compiledData.functions`(allFunctions)

// The function finds out if a group with the specified name exists.
def groupIsExist?(compiledData CData, groupName String) Bool
    const splitedName Array = groupName.splitByPart("::")
    const moduleName String = splitedName[0]
    const shortGroupName String = splitedName[1]
    const allGroupsWithSameName <>Map = compiledData.groups~()[shortGroupName]
    return !(allGroupsWithSameName.nothing?() || allGroupsWithSameName[moduleName].nothing?())

// The function adds a group to existing groups.
def addCGroup(write compiledData CData, group CGroup)
    const splitedName Array = group.fullName~().splitByPart("::")
    const moduleName String = splitedName[0]
    const groupName String = splitedName[1]
    var groups Map = compiledData.groups`(nothing)
    var allGroupsWithSameName <>Map = groups.put(groupName, Map.createEmpty())
    if allGroupsWithSameName.nothing?()
        allGroupsWithSameName = Map.createEmpty()
    allGroupsWithSameName.put(moduleName, group)
    groups.put(groupName, allGroupsWithSameName)
    compiledData.groups`(groups)

// The function adds a type to existing types.
def addCType(write compiledData CData, type CType)
    const splitedName Array = type.fullName~().splitByPart("::")
    const moduleName String = splitedName[0]
    const typeName String = splitedName[1]
    var types Map = compiledData.types`(nothing)
    var allTypesWithSameName <>Map = types.put(typeName, Map.createEmpty())
    if allTypesWithSameName.nothing?()
        allTypesWithSameName = Map.createEmpty()
    allTypesWithSameName.put(moduleName, type)
    types.put(typeName, allTypesWithSameName)
    compiledData.types`(types)

// The function writes the compiled data to a file.
#noinline
def createModule(compiledData CData, outputFile String)
    var fileData Bytes = moduleSignature()
    const currentModuleName String = compiledData.currentModule~()
    currentModuleName.serialize(fileData)
    var elements Map = Map.createEmpty()
    parse elementName, elementsWithName = compiledData.enumerationsElements~()
        parse moduleName, isExport = elementsWithName
            if moduleName == currentModuleName
                elements.put(elementName, isExport)
    elements.length~().serialize(fileData)
    parse elementName, isExport = elements
        elementName.serialize(fileData)
        isExport.serialize(fileData)
    var constants Array = []
    parse _, constantsWithName = compiledData.constants~()
        parse moduleName, constant = constantsWithName
            if moduleName == currentModuleName
                constants.addItem(constant)
    constants.length~().serialize(fileData)
    parse _, constant = constants
        constant.serialize(fileData)
    var types Array = []
    parse _, typesWithName = compiledData.types~()
        parse moduleName, type = typesWithName
            if moduleName == currentModuleName
                types.addItem(type)
    types.length~().serialize(fileData)
    parse _, type = types
        type.serialize(fileData)
    var groups Array = []
    parse _, groupsWithName = compiledData.groups~()
        parse moduleName, group = groupsWithName
            if moduleName == currentModuleName
                groups.addItem(group)
    groups.length~().serialize(fileData)
    parse _, group = groups
        group.serialize(fileData)
    var functions Array = []
    parse functionName, functionsWithName = compiledData.functions~()
        parse moduleName, function = functionsWithName
            tSwitch function.finalFunction~()
            case GroupFunctions
                const groupFunctions GroupFunctions = function.finalFunction~()
                parse thisType, simpleFunction = groupFunctions.functions~()
                    if simpleFunction.fromCurrentModule?()
                        functions.addItem{
                            (moduleFunction(
                                function.export?(),
                                functionName,
                                moduleName,
                                groupFunctions.group~(),
                                thisType,
                                simpleFunction
                            ))
                        }
            case SimpleFunction
                const simpleFunction SimpleFunction = function.finalFunction~()
                if simpleFunction.fromCurrentModule?()
                    functions.addItem{
                        (moduleFunction(
                            function.export?(),
                            functionName,
                            moduleName,
                            "",
                            "",
                            simpleFunction
                        ))
                    }
    functions.length~().serialize(fileData)
    parse _, function = functions
        function.serialize(fileData)
    const file <>File = openFile(outputFile, enum::fmode_write)
    if file.nothing?() || writeDataToFile(file, fileData.length~(), fileData) != fileData.length~()
        errorCanNotWriteToFile(outputFile)

// The function creates a file with the final program.
#noinline
def createProgram(compiledData CData, outputFile String)
    var compilingConstants Set = Set.createEmpty()
    var compilingFunctions Set = Set.createEmpty()
    var groupsTypes Map = Map.createEmpty()
    parse _, groups = compiledData.groups~()
        parse _, group = groups
            groupsTypes.put(group.fullName~(), Set.createEmpty())
    const alwaysUsedTypes Map = alwaysUsedTypes()
    parse typeName, _ = alwaysUsedTypes
        const typeGroups Set = compiledData.getType(const::emptyToken.replaceText(typeName), true).groups~()
        parse _, group = typeGroups
            var groupTypes Set = groupsTypes.put(group, Set.createEmpty())
            groupTypes.add(typeName)
            groupsTypes.put(group, groupTypes)
    var usedData UsedData = usedData{
        (builtinEnumerationsElements(),
        Map.createEmpty(),
        alwaysUsedTypes,
        Map.createEmpty(),
        Map.createEmpty(),
        builtinConstantStrings(),
        builtinLLVMDeclaredFunctions(),
        Map.createEmpty(),
        groupsTypes,
        Map.createEmpty())
    }
    var mainFunctionMayThrow Bool = true
    try
        mainFunctionMayThrow = !compiledData.getFunction(const::emptyToken.replaceText("Main::main"), true).finalFunction~().attributes~().nothrow?()
    catch
        errorNotFoundMainFunction()
    compilingFunctions.add(const::emptyToken.replaceText("Main::main0".addItem$(mainFunctionMayThrow.select('1', '0'))))
    for :(loop)
        for !compilingConstants.empty?()
            var constantName Token = const::emptyToken
            parse :(parse) _, constant = compilingConstants
                constantName = constant
                end parse
            if !constantName.empty?()
                compilingConstants.remove(constantName)
                compiledData.constantToFinalLLVMIR(constantName, compilingConstants, compilingFunctions, usedData)
        for !compilingFunctions.empty?()
            var functionName Token = const::emptyToken
            parse :(parse) _, function = compilingFunctions
                functionName = function
                end parse
            if !functionName.empty?()
                compilingFunctions.remove(functionName)
                compiledData.functionToFinalLLVMIR(functionName, compilingConstants, compilingFunctions, usedData)
        if compilingConstants.empty?()
            end loop
    var llvmIR String = builtinConstants()
    var constantsArray Array = Array.repeat("", usedData.llvmConstants~().length~())
    parse code, name = usedData.llvmConstants~()
        var index Int = 0
        try
            index = Int.fromString(name[4 : name.length~()])
        catch
            unreachable()
        constantsArray.setItem(index, name + " = " + code + "\n")
    parse _, line = constantsArray
        llvmIR += line
    var genericFunctionsErrors Map = Map.createEmpty()
    var idCounter Int = usedData.llvmConstants~().length~()
    parse functionNameWithVariant, functionCode = usedData.functions~()
        if functionCode[0] == '|'
            const functionName String = functionNameWithVariant[0: functionNameWithVariant.length~() - 2]
            var llvmStringType String = ""
            const llvmStringData String = stringToLLVMArray(const::emptyToken.replaceText("Invalid type.\\n<- " + functionName), llvmStringType)
            const stringConstantName String = "@lc." + idCounter.toString()
            idCounter++
            llvmIR += stringConstantName + " = private unnamed_addr constant " + llvmStringType + " " + llvmStringData + ", align 8\n"
            const errorConstantName String = "@lc." + idCounter.toString()
            idCounter++
            llvmIR += errorConstantName + " = private unnamed_addr constant [3 x i64] [i64 0, i64 ptrtoint (" + llvmStringType + "* " + stringConstantName + " to i64), i64 0], align 8\n"
            genericFunctionsErrors.put(functionName, "[i64 1, i64 ptrtoint([3 x i64]* " + errorConstantName + " to i64)]")
    constantsArray = Array.repeat("", usedData.types~().length~())
    parse typeName, typeNumber = usedData.types~()
        var llvmStringType String = ""
        const llvmStringData String = stringToLLVMArray(const::emptyToken.replaceText(typeName), llvmStringType)
        var index Int = 0
        try
            index = Int.fromString(typeNumber)
        catch
            unreachable()
        const stringConstantName String = "@ctnc." + typeNumber
        constantsArray.setItem{
            (index,
            stringConstantName + " = private unnamed_addr constant " + llvmStringType + " " + llvmStringData + ", align 8\n"
            "@ctn." + typeNumber + " = private unnamed_addr constant [2 x i64] [i64 4, i64 ptrtoint(" + llvmStringType + "* " + stringConstantName + " to i64)], align 8\n")
        }
    parse _, line = constantsArray
        llvmIR += line
    constantsArray = []
    llvmIR += "\n"
    var constantsInitFunction String = "define private void @constnants.init() nounwind noinline{\n"
    var registerNumber Int = 1
    parse constantName, code = usedData.constants~()
        constantsInitFunction += "\t%" + registerNumber.toString() + " = call [2 x i64] @get.c." + constantName.replacePart$("::", ".") + "() noinline\n"
        llvmIR += code + "\n"
        registerNumber++
    llvmIR += constantsInitFunction + "\tret void\n}\n\n" + builtinFunctions(mainFunctionMayThrow)
    parse functionNameWithVariant, functionCode = usedData.functions~()
        if functionCode[0] == '|'
            const functionName String = functionNameWithVariant[0 : functionNameWithVariant.length~() - 2]
            const functionVariant String = functionNameWithVariant[functionName.length~() : functionNameWithVariant.length~()]
            const functionData Array = functionCode.split('|')
            const thisTypeArgumentIndex String = functionData[1]
            var newRegisterNumber Int = Int.fromString(functionData[2])
            const group String = functionData[3]
            const llvmFunctionType String = functionData[4]
            const llvmFunctionSignature String = functionData[5]
            const thisTypeArgumentIsMutable Bool = functionData[6][0] == '1'
            const groupTypes Set = usedData.groupsTypes~()[group]
            var brs String = ""
            llvmIR += llvmFunctionSignature
            if !groupsTypes.empty?()
                var typeRegister String = newRegisterNumber.toString()
                if thisTypeArgumentIsMutable
                    const typePointerRegister String = typeRegister
                    typeRegister = (newRegisterNumber + 1).toString()
                    llvmIR += {
                        "\t%" + typePointerRegister + " = getelementptr [2 x i64], [2 x i64]* %" + thisTypeArgumentIndex + ", i64 0, i32 0\n"
                        "\t%" + typeRegister + " = load i64, i64* %" + typePointerRegister + "\n"
                    }
                    newRegisterNumber += 2
                else
                    llvmIR += "\t%" + typeRegister + " = extractvalue [2 x i64] %" + thisTypeArgumentIndex + ", 0\n"
                    newRegisterNumber++
                llvmIR += "\tswitch i64 %" + typeRegister + ", label %" + newRegisterNumber.toString() + " [\n"
                brs = "\t" + newRegisterNumber.toString() + ":\n"
                newRegisterNumber++
            brs += "\tret [2 x i64] " + genericFunctionsErrors[functionName] + "\n"
            if !groupsTypes.empty?()
                // [[ (number | 0x4000000000000000).toString(), numberAsString, name] ...]
                var typesInGroups Array = []
                parse _, typeName = groupTypes
                    const typeNumberAsString String = usedData.types~()[typeName]
                    var typeNumber Int = 0
                    try
                        typeNumber = Int.fromString(typeNumberAsString)
                    catch
                        unreachable()
                    typesInGroups.addItem([(typeNumber | 0x4000000000000000).toString(), typeNumberAsString, typeName])
                typesInGroups.sort(true)
                var llvmArgumentsInCall String = "("
                const splitedLLVmFunctionType Array = llvmFunctionType.split(']')
                parse argumentRegisterNumber, afterTypePart = splitedLLVmFunctionType[2 : splitedLLVmFunctionType.length~()]
                    llvmArgumentsInCall += (afterTypePart[0] == '*').select("[2 x i64]* %", "[2 x i64] %") + argumentRegisterNumber.toString() + ", "
                llvmArgumentsInCall.copy(llvmArgumentsInCall.length~() - 2, ")\n", 0, 2)
                parse _, type = typesInGroups
                    const newRegister String = newRegisterNumber.toString()
                    newRegisterNumber++
                    const resultRegister String = newRegisterNumber.toString()
                    newRegisterNumber++
                    llvmIR += "\t\ti64 " + type[1] + ", label %" + newRegister + "\n"
                    brs += {
                        "\t" + newRegister + ":\n"
                        "\t%" + resultRegister + " = call [2 x i64] " + createFunctionLLVMName(functionName, type[2], functionVariant[0] == '1', functionVariant[1] == '1') + llvmArgumentsInCall +
                        "\tret [2 x i64] %" + resultRegister + "\n"
                    }
                llvmIR += "\t]\n" + brs
            llvmIR += "}\n\n"
        else
            llvmIR += functionCode
    parse groupsAsString, functionName = usedData.inGroups~()
        llvmIR += "define private i1 " + functionName + "(i64) alwaysinline nounwind{\n"
        const groups Array = groupsAsString.split(',')
        var allTypes Set = usedData.groupsTypes~()[groups[groups.length~() - 1]]
        parse _, groupName = groups[0 : groups.length~() - 1]
            const groupTypes Set = usedData.groupsTypes~()[groupName]
            var unneededTypes Array = []
            parse _, type = allTypes
                if !groupTypes[type]
                    unneededTypes.addItem(type)
            parse _, unneededType = unneededTypes
                allTypes.remove(unneededType)
        var functionBody String = ""
        if allTypes.empty?()
            functionBody = "\tret i1 0\n"
        elif allTypes.length~() == usedData.types~().length~()
            functionBody = "\tret i1 1\n"
        else
            var typesNumbersInGroups Array = []
            parse _, typeName = allTypes
                const typeNumberAsString String = usedData.types~()[typeName]
                var typeNumber Int = 0
                try
                    typeNumber = Int.fromString(typeNumberAsString)
                catch
                    unreachable()
                typesNumbersInGroups.addItem(typeNumber)
            typesNumbersInGroups.sort(true)
            functionBody = "\tswitch i64 %0, label %false [\n"
            parse _, typeNumber = typesNumbersInGroups
                functionBody += "\t\ti64 " + typeNumber.toString() + ", label %true\n"
            functionBody += {
                "\t]\n"
                "\ttrue:\n"
                "\tret i1 1\n"
                "\tfalse:\n"
                "\tret i1 0\n"
            }
        llvmIR += functionBody + "}\n\n"
    llvmIR += "define private [2 x i64] @shar.type.number.to.type.name(i64) nounwind{\n\tswitch i64 %0, label %notype [\n"
    var labelNumber Int = 2
    var labelsCode String = ""
    var phiCode String = ""
    for :(index Int = 0) index < usedData.types~().length~(); index++
        const typeNumber String = index.toString()
        const label String = labelNumber.toString()
        llvmIR += "\t\ti64 " + typeNumber + ", label %" + label + "\n"
        labelsCode += "\t" + label + ":\n\tbr label %end\n"
        phiCode += "[@ctn." + typeNumber + ", %" + label + "], "
        labelNumber++
    const phiRegisterNumber String = labelNumber.toString()
    const resultRegisterNumber String = (labelNumber + 1).toString()
    llvmIR += {
        "\t]\n" +
        labelsCode +
        "\tnotype:\n"
        "\tbr label %end\n"
        "\tend:\n"
        "\t%" + phiRegisterNumber + " = phi [2 x i64]* " + phiCode + "[@shar.empty.string, %notype]\n"
        "\t%" + resultRegisterNumber + " = load [2 x i64], [2 x i64]* %" + phiRegisterNumber + ", align 8\n"
        "\tret [2 x i64] %" + resultRegisterNumber + "\n}\n\n"
    }
    parse _, declare = usedData.llvmDeclares~()
        llvmIR += declare + "\n"
    if !saveToUTF8File(llvmIR, outputFile)
        errorCanNotWriteToFile(outputFile)

def builtinEnumerationsElements() Map
    var result Map = Map.createEmpty()
    parse index, element = {
        ["STD::error_invalidType",
        "STD::error_noReturnValue",
        "STD::error_noError",
        "STD::error_fail"]
    }
        result.put(element, index.toString())
    return result

def builtinConstantStrings() Map
    var result Map = Map.createEmpty()
    parse index, constant = ["private unnamed_addr constant [21 x i16] [i16 0, i16 0, i16 0, i16 0, i16 13, i16 0, i16 0, i16 0, i16 73, i16 110, i16 118, i16 97, i16 108, i16 105, i16 100, i16 32, i16 116, i16 121, i16 112, i16 101, i16 46], align 8"]
        result.put(constant, "@lc." + index.toString())
    return result

def alwaysUsedTypes() Map
    var result Map = Map.createEmpty()
    parse typeNumber, typeName = {
        ["STD::Nothing",
        "STD::Error",
        "STD::Bool",
        "STD::Int",
        "STD::String"]
    }
        result.put(typeName, typeNumber.toString())
    return result

def builtinLLVMDeclaredFunctions() Map
    var result Map = Map.createEmpty()
    const functions Array = {
        ["shar__get__cmd__argument", "declare i1 @shar__get__cmd__argument(i64, i64, i64* nocapture, i16** nocapture) local_unnamed_addr nounwind",
        "shar__get__cmd__arguments__count", "declare i64 @shar__get__cmd__arguments__count() local_unnamed_addr nounwind readonly",
        "shar__get__env__variable", "declare i1 @shar__get__env__variable(i64, i16* nocapture readonly, i64, i64* nocapture, i16** nocapture) local_unnamed_addr nounwind",
        "shar__get__string__from__cmd__line", "declare i1 @shar__get__string__from__cmd__line(i64, i64* nocapture, i16** nocapture) local_unnamed_addr nounwind",
        "shar__get__platform__name", "declare void @shar__get__platform__name(i64, i64* nocapture, i16** nocapture) local_unnamed_addr nounwind",
        "shar__execute__command", "declare i1 @shar__execute__command(i64, i16* nocapture readonly) local_unnamed_addr nounwind",
        "shar__delete__file", "declare i1 @shar__delete__file(i64, i16* nocapture readonly) local_unnamed_addr nounwind",
        "shar__delete__empty__directory", "declare i1 @shar__delete__empty__directory(i64, i16* nocapture readonly) local_unnamed_addr nounwind",
        "shar__file__is__exist", "declare i1 @shar__file__is__exist(i64, i16* nocapture readonly) local_unnamed_addr nounwind",
        "shar__directory__is__exist", "declare i1 @shar__directory__is__exist(i64, i16* nocapture readonly) local_unnamed_addr nounwind",
        "shar__open__file", "declare i1 @shar__open__file(i64, i16* nocapture readonly, i32, i8** nocapture) local_unnamed_addr nounwind",
        "shar__flush__file", "declare i1 @shar__flush__file(i8* nocapture) local_unnamed_addr nounwind",
        "shar__close__file", "declare i1 @shar__close__file(i8* nocapture) local_unnamed_addr nounwind",
        "shar__read__from__file", "declare i64 @shar__read__from__file(i8* nocapture, i64, i8* nocapture) local_unnamed_addr nounwind",
        "shar__write__to__file", "declare i64 @shar__write__to__file(i8* nocapture, i64, i8* nocapture) local_unnamed_addr nounwind",
        "shar__get__file__size", "declare i64 @shar__get__file__size(i64, i16* nocapture readonly) local_unnamed_addr nounwind",
        "shar__get__position__in__file", "declare i64 @shar__get__position__in__file(i8* nocapture) local_unnamed_addr nounwind",
        "shar__set__position__in__file", "declare i1 @shar__set__position__in__file(i8* nocapture, i64) local_unnamed_addr nounwind",
        "shar__file__rename", "declare i1 @shar__file__rename(i64, i16* nocapture readonly, i64, i16* nocapture readonly) local_unnamed_addr nounwind",
        "shar__open__directory", "declare i1 @shar__open__directory(i64, i16* nocapture readonly, i64*) local_unnamed_addr nounwind",
        "shar__read__directory", "declare i1 @shar__read__directory(i64, i64, i64* nocapture, i16** nocapture, i8* nocapture) local_unnamed_addr nounwind",
        "shar__close__directory", "declare void @shar__close__directory(i64) local_unnamed_addr nounwind",
        "shar__make__directory", "declare i1 @shar__make__directory(i64, i16* nocapture readonly, i1) local_unnamed_addr nounwind",
        "shar__print__string", "declare void @shar__print__string(i64, i16* nocapture readonly) local_unnamed_addr nounwind",
        "shar__println__string", "declare void @shar__println__string(i64, i16* nocapture readonly) local_unnamed_addr nounwind",
        "shar__print__as__error", "declare void @shar__print__as__error(i64, i16* nocapture readonly) local_unnamed_addr nounwind",
        "shar__println__as__error", "declare void @shar__println__as__error(i64, i16* nocapture readonly) local_unnamed_addr nounwind",
        "shar__print__error", "declare void @shar__print__error(i64, i16* nocapture readonly) local_unnamed_addr cold noreturn nounwind",
        "shar__print__builtin__error", "declare void @shar__print__builtin__error(i8*) local_unnamed_addr cold noreturn nounwind",
        "shar__get__random__number", "declare i64 @shar__get__random__number() local_unnamed_addr nounwind",
        "shar__get__cryptographic__random__number", "declare i64 @shar__get__cryptographic__random__number() local_unnamed_addr nounwind",
        "shar__get__current__time", "declare i64 @shar__get__current__time() local_unnamed_addr nounwind",
        "shar__load__lib", "declare i1 @shar__load__lib(i64, i16* nocapture readonly, i8** nocapture) local_unnamed_addr nounwind",
        "shar__get__from__lib", "declare i1 @shar__get__from__lib(i64, i16* nocapture readonly, i8*, i8** nocapture) local_unnamed_addr nounwind",
        "shar__unload__lib", "declare i1 @shar__unload__lib(i8*) local_unnamed_addr nounwind",
        "shar__pipeline__use__counter__inc", "declare void @shar__pipeline__use__counter__inc(i64) local_unnamed_addr nounwind",
        "shar__pipeline__use__counter__dec", "declare i1 @shar__pipeline__use__counter__dec(i64) local_unnamed_addr nounwind",
        "shar__pipeline__get__data__for__free", "declare i64 @shar__pipeline__get__data__for__free(i64) local_unnamed_addr nounwind",
        "shar__pipeline__get__count__for__free", "declare i64 @shar__pipeline__get__count__for__free(i64) local_unnamed_addr nounwind",
        "shar__create__pipeline", "declare i64 @shar__create__pipeline() local_unnamed_addr nounwind",
        "shar__pipeline__push", "declare void @shar__pipeline__push(i64, [2 x i64]) local_unnamed_addr nounwind",
        "shar__pipeline__pop", "declare [2 x i64] @shar__pipeline__pop(i64) local_unnamed_addr nounwind",
        "shar__destroy__pipeline", "declare void @shar__destroy__pipeline(i64) local_unnamed_addr nounwind",
        "shar__create__worker", "declare void @shar__create__worker([2 x i64] ([2 x i64], [2 x i64])*, [2 x i64], [2 x i64], [2 x i64] ([2 x i64])*) local_unnamed_addr nounwind",
        "shar__yield", "declare void @shar__yield() local_unnamed_addr nounwind",
        "shar__sleep", "declare void @shar__sleep(i64) local_unnamed_addr nounwind",
        "shar__get__language__code", "declare i16 @shar__get__language__code() local_unnamed_addr nounwind",
        "shar__init", "declare void @shar__init(i32, i8**) local_unnamed_addr nounwind",
        "shar__enable__threads", "declare void @shar__enable__threads() local_unnamed_addr nounwind",
        "shar__end", "declare void @shar__end() local_unnamed_addr nounwind",
        "shar__exit", "declare void @shar__exit() local_unnamed_addr nounwind cold noreturn",
        "llvm.expect.i1", "declare i1 @llvm.expect.i1(i1, i1)",
        "llvm.assume", "declare void @llvm.assume(i1)",
        "llvm.memcpy.i16.i16.i64", "declare void @llvm.memcpy.i16.i16.i64(i16*, i16*, i64, i1)",
        "malloc", "declare noalias i8* @malloc(i64) local_unnamed_addr nofree nounwind",
        "realloc", "declare noalias i8* @realloc(i8* nocapture, i64) local_unnamed_addr nounwind",
        "free", "declare void @free(i8* nocapture) local_unnamed_addr nounwind"]
    }
    for :(index Int = 0) index < functions.length~(); index += 2
        result.put(functions[index], functions[index + 1])
    return result

def builtinConstants() String
    return {
        "@empty.string = private unnamed_addr constant [8 x i16] zeroinitializer, align 8\n"
        "@shar.empty.string = private unnamed_addr constant [2 x i64] [i64 4, i64 ptrtoint ([8 x i16]* @empty.string to i64)], align 8\n"
        "@empty.list = private unnamed_addr constant [2 x i64] zeroinitializer, align 8\n"
        "@empty.array = private unnamed_addr constant [3 x i64] zeroinitializer, align 8\n"
        "@not.enough.memory.message = private unnamed_addr constant [20 x i8] c\qNot enough memory.\\0A\\00\q, align 1\n"
        "@invalid.type.error = private unnamed_addr constant [3 x i64] [i64 0, i64 ptrtoint([21 x i16]* @lc.0 to i64), i64 0], align 8\n\n"
    }

def builtinFunctions(mainFunctionMayThrow Bool) String
    return {
        "define i32 @main(i32, i8** nocapture readnone) local_unnamed_addr sspstrong nounwind{\n"
        "\tcall void @shar__init(i32 %0, i8** %1)\n"
        "\tcall void @constnants.init()\n"
        "\tcall void @shar__enable__threads()\n"
        "\t%3 = call [2 x i64] " + createFunctionLLVMName("Main::main", "", false, mainFunctionMayThrow) + "()\n"
        "\t%4 = extractvalue [2 x i64] %3, 0\n"
        "\t%5 = icmp eq i64 %4, 1\n"
        "\tbr i1 %5, label %6, label %22\n"
        "\t6:\n"
        "\t%7 = extractvalue [2 x i64] %3, 1\n"
        "\t%8 = inttoptr i64 %7 to i64*\n"
        "\t%9 = getelementptr i64, i64* %8, i64 0\n"
        "\t%10 = load i64, i64* %9, align 8\n"
        "\t%11 = icmp eq i64 %10, 2\n"
        "\t%12 = icmp eq i64 %10, 3\n"
        "\t%13 = or i1 %11, %12\n"
        "\tbr i1 %13, label %22, label %14\n"
        "\t14:\n"
        "\t%15 = getelementptr i64, i64* %8, i64 1\n"
        "\t%16 = load i64, i64* %15, align 8\n"
        "\t%17 = inttoptr i64 %16 to i64*\n"
        "\t%18 = getelementptr i64, i64* %17, i64 1\n"
        "\t%19 = getelementptr i64, i64* %17, i64 2\n"
        "\t%20 = load i64, i64* %18, align 8\n"
        "\t%21 = bitcast i64* %19 to i16*\n"
        "\tcall void @shar__print__error(i64 %20, i16* %21)\n"
        "\tunreachable\n"
        "\t22:\n"
        "\t%23 = phi i1 [0, %2], [%12, %6]\n"
        "\tcall void @shar__end()\n"
        "\t%24 = zext i1 %23 to i32\n"
        "\tret i32 %24\n"
        "}\n\n"
        "define private i64* @shar.malloc(i64) alwaysinline nounwind {\n"
        "\t%2 = call i8* @malloc(i64 %0)\n"
        "\t%3 = icmp eq i8* %2, null\n"
        "\t%4 = call i1 @llvm.expect.i1(i1 %3, i1 0)\n"
        "\tbr i1 %4, label %5, label %7\n"
        "\t5:\n"
        "\t%6 = bitcast [20 x i8]* @not.enough.memory.message to i8*\n"
        "\tcall void @shar__print__builtin__error(i8* %6)\n"
        "\tunreachable\n"
        "\t7:\n"
        "\t%8 = bitcast i8* %2 to i64*\n"
        "\tret i64* %8\n"
        "}\n\n"
        "define private i64* @shar.realloc(i64*, i64) alwaysinline nounwind {\n"
        "\t%3 = bitcast i64* %0 to i8*\n"
        "\t%4 = call i8* @realloc(i8* %3, i64 %1)\n"
        "\t%5 = icmp eq i8* %4, null\n"
        "\t%6 = call i1 @llvm.expect.i1(i1 %5, i1 0)\n"
        "\tbr i1 %6, label %7, label %9\n"
        "\t7:\n"
        "\t%8 = bitcast [20 x i8]* @not.enough.memory.message to i8*\n"
        "\tcall void @shar__print__builtin__error(i8* %8)\n"
        "\tunreachable\n"
        "\t9:\n"
        "\t%10 = bitcast i8* %4 to i64*\n"
        "\tret i64* %10\n"
        "}\n\n"
        "define private void @shar.free(i64*) alwaysinline nounwind {\n"
        "\t%2 = bitcast i64* %0 to i8*\n"
        "\tcall void @free(i8* %2)\n"
        "\tret void\n"
        "}\n\n"
        "define private [2 x i64] @shar.error.get.id([2 x i64]) alwaysinline nounwind {\n"
        "\t%2 = extractvalue [2 x i64] %0, 1\n"
        "\t%3 = inttoptr i64 %2 to i64*\n"
        "\t%4 = load i64, i64* %3, align 8\n"
        "\t%5 = insertvalue [2 x i64] [i64 3, i64 0], i64 %4, 1\n"
        "\tret [2 x i64] %5\n"
        "}\n\n"
        "define private [2 x i64] @shar.error.get.message([2 x i64]) alwaysinline nounwind {\n"
        "\t%2 = extractvalue [2 x i64] %0, 1\n"
        "\t%3 = inttoptr i64 %2 to i64*\n"
        "\t%4 = getelementptr i64, i64* %3, i64 1\n"
        "\t%5 = load i64, i64* %4, align 8\n"
        "\t%6 = insertvalue [2 x i64] [i64 4, i64 0], i64 %5, 1\n"
        "\tret [2 x i64] %6\n"
        "}\n\n"
        "define private void @shar.error.free([2 x i64]) noinline nounwind {\n"
        "\t%2 = extractvalue [2 x i64] %0, 1\n"
        "\t%3 = inttoptr i64 %2 to i64*\n"
        "\t%4 = getelementptr i64, i64* %3, i64 2\n"
        "\t%5 = load i64, i64* %4, align 8\n"
        "\t%6 = trunc i64 %5 to i1\n"
        "\tbr i1 %6, label %7, label %18\n"
        "\t7:\n"
        "\t%8 = getelementptr i64, i64* %3, i64 1\n"
        "\t%9 = load i64, i64* %8, align 8\n"
        "\t%10 = inttoptr i64 %9 to i64*\n"
        "\tcall void @shar.free(i64* %3)\n"
        "\t%11 = load i64, i64* %10, align 8\n"
        "\t%12 = icmp eq i64 %11, 1\n"
        "\tbr i1 %12, label %13, label %14\n"
        "\t13:\n"
        "\tcall void @shar.free(i64* %10)\n"
        "\tbr label %18\n"
        "\t14:\n"
        "\t%15 = icmp eq i64 %11, 0\n"
        "\tbr i1 %15, label %18, label %16\n"
        "\t16:\n"
        "\t%17 = sub i64 %11, 1\n"
        "\tstore i64 %17, i64* %10, align 8\n"
        "\tbr label %18\n"
        "\t18:\n"
        "\tret void\n"
        "}\n\n"
        "define private [2 x i64] @shar.error.add.to.message([2 x i64], i64) noinline nounwind {\n"
        "\t%3 = extractvalue [2 x i64] %0, 1\n"
        "\t%4 = inttoptr i64 %3 to i64*\n"
        "\t%5 = load i64, i64* %4, align 8\n"
        "\t%6 = icmp eq i64 %5, 2\n"
        "\t%7 = inttoptr i64 %1 to i64*\n"
        "\t%8 = getelementptr i64, i64* %7, i64 1\n"
        "\t%9 = load i64, i64* %8, align 8\n"
        "\t%10 = icmp eq i64 %9, 0\n"
        "\t%11 = or i1 %6, %10\n"
        "\tbr i1 %11, label %54, label %12\n"
        "\t12:\n"
        "\t%13 = mul i64 %9, 2\n"
        "\t%14 = getelementptr i64, i64* %7, i64 2\n"
        "\t%15 = bitcast i64* %14 to i16*\n"
        "\t%16 = getelementptr i64, i64* %4, i64 1\n"
        "\t%17 = load i64, i64* %16, align 8\n"
        "\t%18 = inttoptr i64 %17 to i64*\n"
        "\t%19 = load i64, i64* %18, align 8\n"
        "\t%20 = getelementptr i64, i64* %18, i64 1\n"
        "\t%21 = load i64, i64* %20, align 8\n"
        "\t%22 = mul i64 %21, 2\n"
        "\t%23 = getelementptr i64, i64* %18, i64 2\n"
        "\t%24 = bitcast i64* %23 to i16*\n"
        "\t%25 = add i64 %9, %21\n"
        "\t%26 = add i64 %25, 8\n"
        "\t%27 = mul i64 %26, 2\n"
        "\tswitch i64 %19, label %28 [\n"
        "\t\ti64 0, label %30\n"
        "\t\ti64 1, label %34\n"
        "\t]\n"
        "\t28:\n"
        "\t%29 = sub i64 %19, 1\n"
        "\tstore i64 %29, i64* %18, align 8\n"
        "\tbr label %30\n"
        "\t30:\n"
        "\t%31 = call i64* @shar.malloc(i64 %27)\n"
        "\tstore i64 1, i64* %31, align 8\n"
        "\t%32 = getelementptr i64, i64* %31, i64 2\n"
        "\t%33 = bitcast i64* %32 to i16*\n"
        "\tcall void @llvm.memcpy.i16.i16.i64(i16* nonnull align 2 %33, i16* nonnull align 2 %24, i64 %22, i1 0)\n"
        "\tbr label %36\n"
        "\t34:\n"
        "\t%35 = call i64* @shar.realloc(i64* %18, i64 %27)\n"
        "\tbr label %36\n"
        "\t36:\n"
        "\t%37 = phi i64* [%31, %30], [%35, %34]\n"
        "\t%38 = getelementptr i64, i64* %37, i64 1\n"
        "\tstore i64 %25, i64* %38, align 8\n"
        "\t%39 = getelementptr i64, i64* %37, i64 2\n"
        "\t%40 = bitcast i64* %39 to i16*\n"
        "\t%41 = getelementptr i16, i16* %40, i64 %21\n"
        "\tcall void @llvm.memcpy.i16.i16.i64(i16* nonnull align 2 %41, i16* nonnull align 2 %15, i64 %13, i1 0)\n"
        "\t%42 = getelementptr i64, i64* %4, i64 2\n"
        "\t%43 = load i64, i64* %42, align 8\n"
        "\t%44 = trunc i64 %43 to i1\n"
        "\tbr i1 %44, label %48, label %45\n"
        "\t45:\n"
        "\t%46 = call i64* @shar.malloc(i64 24)\n"
        "\tstore i64 %5, i64* %46, align 8\n"
        "\t%47 = getelementptr i64, i64* %46, i64 2\n"
        "\tstore i64 1, i64* %47, align 8\n"
        "\tbr label %48\n"
        "\t48:\n"
        "\t%49 = phi i64* [%4, %36], [%46, %45]\n"
        "\t%50 = getelementptr i64, i64* %49, i64 1\n"
        "\t%51 = ptrtoint i64* %37 to i64\n"
        "\tstore i64 %51, i64* %50, align 8\n"
        "\t%52 = ptrtoint i64* %49 to i64\n"
        "\t%53 = insertvalue [2 x i64] %0, i64 %52, 1\n"
        "\tbr label %54\n"
        "\t54:\n"
        "\t%55 = phi [2 x i64] [%0, %2], [%53, %48]\n"
        "\tret [2 x i64] %55\n"
        "}\n\n"
    }
