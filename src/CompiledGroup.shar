module Main

// Compiled group.
type CGroup
    // export?      Bool
    // fullName     String
    // subGroups    Set of String
    // functions    Set of String

attach CGroup to FieldExport
    #alwaysinline
    def export?(group CGroup) Bool
        return group.typeGetItem(0)

    #alwaysinline
    def export`(write group CGroup, new Bool) Bool
        return group.typePut(0, new)

attach CGroup to FieldFullName
    #alwaysinline
    def fullName~(group CGroup) String
        return group.typeGetItem(1)

    #alwaysinline
    def fullName`(write group CGroup, new String) String
        return group.typePut(1, new)

attach CGroup to FieldSubGroups
    #alwaysinline
    def subGroups~(group CGroup) Set
        return group.typeGetItem(2)

    #alwaysinline
    def subGroups`(write group CGroup, new <>Set) <>Set
        return group.typePut(2, new)

attach CGroup to FieldFunctions
    #alwaysinline
    def functions~(group CGroup) Set
        return group.typeGetItem(3)

    #alwaysinline
    def functions`(write group CGroup, new <>Set) <>Set
        return group.typePut(3, new)

#alwaysinline
def cGroup(isExport Bool, fullName String, allSubGroups, functions Set) CGroup
    return CGroup.fromList({isExport, fullName, allSubGroups, functions})

attach CGroup to BinarySerializable
    #alwaysinline
    def serialize(group CGroup, write bytes Bytes)
        const isExport Bool = group.export?()
        const fullName String = group.fullName~()
        const shortName String = fullName.splitByPart("::")[1]
        const allSubGroups Set = group.subGroups~()
        const functions Set = group.functions~()
        isExport.serialize(bytes)
        shortName.serialize(bytes)
        allSubGroups.length~().serialize(bytes)
        parse _, subGroup = allSubGroups
            subGroup.serialize(bytes)
        functions.length~().serialize(bytes)
        parse _, functionName = functions
            functionName.serialize(bytes)

    #alwaysinline
    def deserialize(noread type CGroup, bytes Bytes, write position Int) CGroup
        const startPosition Int = position
        try
            const isExport Bool = Bool.deserialize(bytes, position)
            const name String = String.deserialize(bytes, position)
            const subGroupsCount Int = Int.deserialize(bytes, position)
            var subGroups Set = Set.createEmpty()
            for :(counter Int = 0) counter < subGroupsCount; counter++
                subGroups.add(String.deserialize(bytes, position))
            const functionsCount Int = Int.deserialize(bytes, position)
            var functions Set = Set.createEmpty()
            for :(counter Int = 0) counter < functionsCount; counter++
                functions.add(String.deserialize(bytes, position))
            return cGroup(isExport, name, subGroups, functions)
        catch id, message
            position = startPosition
            throw(id, message)

// The function imports data from one group to another.
#alwaysinline
def importDataFromGroup(write destination, source CGroup)
    var allSubGroups Set = destination.subGroups`(nothing)
    allSubGroups.add(source.fullName~())
    parse _, subGroup = source.subGroups~()
        allSubGroups.add(subGroup)
    allSubGroups.add("STD::Any")
    destination.subGroups`(allSubGroups)
