module Main

// Compiled constant.
type CConstant
    // export?  Bool
    // fullname String
    // llvmIR   String
    // type     OType

#alwaysinline
def cConstant(isExport Bool, fullName, llvmIR String, type OType) CConstant
    return CConstant.fromList({isExport, fullName, llvmIR, type})

attach CConstant to FieldExport
    #alwaysinline
    def export?(constant CConstant) Bool
        return constant.typeGetItem(0)

    #alwaysinline
    def export`(write constant CConstant, new Bool) Bool
        return constant.typePut(0, new)

attach CConstant to FieldFullName
    #alwaysinline
    def fullName~(constant CConstant) String
        return constant.typeGetItem(1)

    #alwaysinline
    def fullName`(write constant CConstant, new String) String
        return constant.typePut(1, new)

attach CConstant to FieldLLVMIR
    #alwaysinline
    def llvmIR~(constant CConstant) String
        return constant.typeGetItem(2)

    #alwaysinline
    def llvmIR`(write constant CConstant, new String) String
        return constant.typePut(2, new)

attach CConstant to FieldType
    #alwaysinline
    def type~(constant CConstant) OType
        return constant.typeGetItem(3)

    #alwaysinline
    def type`(write constant CConstant, new <>OType) <>OType
        return constant.typePut(3, new)

attach CConstant to BinarySerializable
    #alwaysinline
    def serialize(constant CConstant, write bytes Bytes)
        const isExport Bool = constant.export?()
        const fullName String = constant.fullName~()
        const shortName String = fullName.splitByPart("::")[1]
        const llvmIR String = constant.llvmIR~()
        const type OType = constant.type~()
        isExport.serialize(bytes)
        shortName.serialize(bytes)
        llvmIR.serialize(bytes)
        type.serialize(bytes)

    #alwaysinline
    def deserialize(noread type CConstant, bytes Bytes, write position Int) CConstant
        const startPosition Int = position
        try
            const isExport Bool = Bool.deserialize(bytes, position)
            const name String = String.deserialize(bytes, position)
            const llvmIR String = String.deserialize(bytes, position)
            const oType OType = OType.deserialize(bytes, position)
            return cConstant(isExport, name, llvmIR, oType)
        catch id, message
            position = startPosition
            throw(id, message)

// The function generates llvm ir code for a constant.
def constantToFinalLLVMIR(compiledData CData, constantName Token, write compilingConstants, write compilingFunctions Set, write usedData UsedData)
    if !usedData.constants~()[constantName.text~()].nothing?()
        return
    if !constantName.text~().containPart?("::")
        errorNotFound(constantName, "constant")
    const constant CConstant = compiledData.getConstant(constantName, true)
    const llvmName String = constant.fullName~().getConstantLLVMName()
    const errorType String = "[" + (23 + constant.fullName~().length~()).toString() + " x i8]"
    const llvmIR String = {
        "@" + llvmName + " = private unnamed_addr global {[2 x i64], i8} zeroinitializer, align 8\n"
        "@" + llvmName + ".error.message = private unnamed_addr constant " + errorType + " c\qRecursive constant \\22" + constant.fullName~() + "\\22.\\00\q, align 1\n\n"
        "define private [2 x i64] @get." + llvmName + "() alwaysinline nounwind{\n"
        "\t%1 = getelementptr {[2 x i64], i8}, {[2 x i64], i8}* @" + llvmName + ", i64 0, i32 0\n"
        "\t%2 = getelementptr {[2 x i64], i8}, {[2 x i64], i8}* @" + llvmName + ", i64 0, i32 1\n"
        "\t%3 = load i8, i8* %2, align 1\n"
        "\t%4 = trunc i8 %3 to i1\n"
        "\t%5 = call i1 @llvm.expect.i1(i1 %4, i1 1)\n"
        "\tbr i1 %5, label %6, label %8\n"
        "\t6:\n"
        "\t%7 = load [2 x i64], [2 x i64]* %1, align 8\n"
        "\tret [2 x i64] %7\n"
        "\t8:\n"
        "\t%9 = icmp eq i8 %3, 2\n"
        "\tbr i1 %9, label %10, label %12\n"
        "\t10:\n"
        "\t%11 = getelementptr " + errorType + ", " + errorType + "* @" + llvmName + ".error.message, i64 0, i32 0\n"
        "\tcall void @shar__print__builtin__error(i8* %11)\n"
        "\tunreachable\n"
        "\t12:\n"
        "\tstore i8 2, i8* %2, align 1\n"
        "\t%13 = call [2 x i64] @calc." + llvmName + "()\n" +
        "\tstore [2 x i64] %13, [2 x i64]* %1, align 8\n" +
        "\tstore i8 1, i8* %2, align 1\n" +
        "\tret [2 x i64] %13\n" +
        "}\n\n" +
        "define private [2 x i64] @calc." + llvmName + "() nounwind noinline{\n" +
        toFinalLLVMIR(constant.llvmIR~(), constantName, compiledData, "", compilingConstants, compilingFunctions, usedData, false, true) +
        "}\n"
    }
    var usedConstants Map = usedData.constants`(nothing)
    usedConstants.put(constant.fullName~(), llvmIR)
    usedData.constants`(usedConstants)
