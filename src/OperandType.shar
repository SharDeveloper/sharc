module Main

// The type specified when declaring any objects.
type OType
    // type simpleType Token | groupType [Token]
    // optional? Bool

const emptyOType OType = OType(const::emptyToken, false)
const boolType OType = OType(const::emptyToken.replaceText("STD::Bool"), false)
const anyType OType = OType([const::emptyToken.replaceText("STD::Any")], false)
const intType OType = OType(const::emptyToken.replaceText("STD::Int"), false)
const charType OType = OType(const::emptyToken.replaceText("STD::Char"), false)
const stringType OType = OType(const::emptyToken.replaceText("STD::String"), false)
const listType OType = OType(const::emptyToken.replaceText("STD::List"), false)

attach OType to FieldType
    #alwaysinline
    def type~(type OType) $Any
        return type.typeGetItem(0)

    #alwaysinline
    def type`(write type OType, new $Any) $Any
        return type.typePut(0, new)

attach OType to FieldOptional
    #alwaysinline
    def optional?(type OType) Bool
        return type.typeGetItem(1)

    #alwaysinline
    def optional`(write type OType, new Bool) Bool
        return type.typePut(1, new)

#alwaysinline
def OType(type $Any, isOptional Bool) OType
    return OType.fromList({type, isOptional})

// The function finds out if the type is simple.
#alwaysinline
def simple?(type OType) Bool
    return type.type~().type?(Token)

// The function finds out if the type is a list of groups.
#alwaysinline
def gType?(type OType) Bool
    return type.type~().type?(Array)

// The function turns the operand type into a token.
#alwaysinline
def oTypeToToken(type OType, withOptionalSignature Bool) Token
    var result Token = const::emptyToken
    if type.simple?()
        result = type.type~()
    else
        const groups Array = type.type~()
        result = groups[0].replaceText("${" + groups[0].text~())
        for :(index Int = 1) index < groups.length~(); index++
            result.addString(",")
            result.addString(groups[index].text~())
        result.addString("}")
    if withOptionalSignature && type.optional?()
        result.text`("<>" + result.text~())
    return result

#alwaysinline
def this?(type OType) Bool
    return type.simple?() && type.type~().text~() == "This"

attach OType to BinarySerializable
    #alwaysinline
    def serialize(type OType, write bytes Bytes)
        if type.simple?()
            true.serialize(bytes)
            type.type~().text~().serialize(bytes)
        else
            false.serialize(bytes)
            const groups Array = type.type~()
            groups.length~().serialize(bytes)
            parse _, group = groups
                group.text~().serialize(bytes)
        type.optional?().serialize(bytes)

    #alwaysinline
    def deserialize(noread type OType, bytes Bytes, write position Int) OType
        const startPosition Int = position
        try
            var result OType = const::emptyOType
            if Bool.deserialize(bytes, position)
                result.type`(const::emptyToken.replaceText(String.deserialize(bytes, position)))
            else
                var groups Array = []
                const length Int = Int.deserialize(bytes, position)
                for :(counter Int = 0) counter < length; counter++
                    groups.addItem(const::emptyToken.replaceText(String.deserialize(bytes, position)))
                result.type`(groups)
            result.optional`(Bool.deserialize(bytes, position))
            return result
        catch id, message
            position = startPosition
            throw(id, message)

attach OType to ToFull
    #alwaysinline
    def toFull(type OType, compiledData CData) OType
        var result OType = OType.fromList({})
        tSwitch type.type~()
        case Token
            var typeToken Token = type.type~()
            if typeToken.text~() == "This"
                result = type
            else
                result = OType(typeToken.replaceText(compiledData.getType(typeToken, false).fullName~()), type.optional?())
        case Array
            var oldGroupsArray Array = type.type~()
            var groupsSet Set = Set()
            parse _, groupName = oldGroupsArray
                const group CGroup = compiledData.getGroup(groupName, false)
                parse _, subGroupName = group.subGroups~()
                    groupsSet.add(groupName.replaceText(subGroupName))
                groupsSet.add(groupName.replaceText(group.fullName~()))
            var newGroupsArray Array = []
            parse _, groupName = groupsSet
                newGroupsArray.addItem(groupName)
            newGroupsArray.sort(true)
            result = OType(newGroupsArray, type.optional?())
        default
            unreachable()
        if (result.nothingType?() || result.anyType?()) && result.optional?()
            const resultToken Token =  result.oTypeToToken(true)
            errorInvalidType(resultToken, resultToken.text~(), resultToken.text~()[2 : resultToken.length~()])
        return result

// The function finds out if the operand type is "Nothing".
#alwaysinline
def nothingType?(type OType) Bool
    return type.simple?() && type.type~().text~() == "STD::Nothing"

// The function finds out if the operand type is "$Any".
#alwaysinline
def anyType?(type OType) Bool
    return type.gType?() && type.type~().length~() == 1 && type.type~()[0].text~() == "STD::Any"

// The function compares two types for equality.
#alwaysinline
def typeEq?(type1, type2 OType, withOptional Bool) Bool
    return type1.simple?() == type2.simple?() && type1.type~() == type2.type~() && (!withOptional || type1.optional?() == type2.optional?())

// The function checks that the two types are equal.
#alwaysinline
def typeEq!(type1, type2 OType, expression Token, withOptional Bool)
    if !type1.typeEq?(type2, withOptional)
        errorInvalidType(expression, oTypeToToken(type1, true).text~(), oTypeToToken(type2, true).text~())
